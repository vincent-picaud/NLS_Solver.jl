<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · NLS_Solver.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://vincent-picaud.github.io/NLS_Solver.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NLS_Solver.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../unconstrained_nls/">Unconstrained nonlinear least squares</a></li><li><a class="tocitem" href="../bound_constrained_nls/">Bound constrained nonlinear least squares</a></li><li><a class="tocitem" href="../nonlinear_regressions/">Nonlinear regressions</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/master/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><p>The global API index is as follows:</p><ul><li><a href="#NLS_Solver.AbstractNLS"><code>NLS_Solver.AbstractNLS</code></a></li><li><a href="#NLS_Solver.Abstract_BC_QuadSolver_Result"><code>NLS_Solver.Abstract_BC_QuadSolver_Result</code></a></li><li><a href="#NLS_Solver.Abstract_BC_Solver_Conf"><code>NLS_Solver.Abstract_BC_Solver_Conf</code></a></li><li><a href="#NLS_Solver.Abstract_BC_Solver_Result"><code>NLS_Solver.Abstract_BC_Solver_Result</code></a></li><li><a href="#NLS_Solver.Abstract_Solver_Conf"><code>NLS_Solver.Abstract_Solver_Conf</code></a></li><li><a href="#NLS_Solver.Abstract_Solver_Result"><code>NLS_Solver.Abstract_Solver_Result</code></a></li><li><a href="#NLS_Solver.BoundConstraint_Enum"><code>NLS_Solver.BoundConstraint_Enum</code></a></li><li><a href="#NLS_Solver.BoundConstraints"><code>NLS_Solver.BoundConstraints</code></a></li><li><a href="#NLS_Solver.LevenbergMarquardt_BC_Conf"><code>NLS_Solver.LevenbergMarquardt_BC_Conf</code></a></li><li><a href="#NLS_Solver.LevenbergMarquardt_BC_Result"><code>NLS_Solver.LevenbergMarquardt_BC_Result</code></a></li><li><a href="#NLS_Solver.LevenbergMarquardt_Conf"><code>NLS_Solver.LevenbergMarquardt_Conf</code></a></li><li><a href="#NLS_Solver.LevenbergMarquardt_Result"><code>NLS_Solver.LevenbergMarquardt_Result</code></a></li><li><a href="#NLS_Solver.NLS_ForwardDiff"><code>NLS_Solver.NLS_ForwardDiff</code></a></li><li><a href="#NLS_Solver.check_first_order-Tuple{AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, BoundConstraints{var&quot;#s2&quot;, 1, LBT, UBT} where {var&quot;#s2&quot;&lt;:Real, LBT&lt;:AbstractVector{var&quot;#s2&quot;}, UBT&lt;:AbstractVector{var&quot;#s2&quot;}}}"><code>NLS_Solver.check_first_order</code></a></li><li><a href="#NLS_Solver.clean_τ!-Tuple{AbstractArray{var&quot;#s9&quot;, N} where {var&quot;#s9&quot;&lt;:Real, N}, AbstractArray{NLS_Solver.BoundConstraint_Enum, N} where N}"><code>NLS_Solver.clean_τ!</code></a></li><li><a href="#NLS_Solver.compute_δL_constrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T, AbstractVector{T} where T}"><code>NLS_Solver.compute_δL_constrained</code></a></li><li><a href="#NLS_Solver.compute_δL_unconstrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T}"><code>NLS_Solver.compute_δL_unconstrained</code></a></li><li><a href="#NLS_Solver.compute_δf-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>NLS_Solver.compute_δf</code></a></li><li><a href="#NLS_Solver.converged-Tuple{Abstract_Solver_Result}"><code>NLS_Solver.converged</code></a></li><li><a href="#NLS_Solver.converged-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.converged</code></a></li><li><a href="#NLS_Solver.create_NLS_problem_using_ForwardDiff-Tuple{Function, Pair{Int64, Int64}}"><code>NLS_Solver.create_NLS_problem_using_ForwardDiff</code></a></li><li><a href="#NLS_Solver.eval_nls_fobj-Tuple{AbstractVector{T} where T}"><code>NLS_Solver.eval_nls_fobj</code></a></li><li><a href="#NLS_Solver.eval_nls_∇fobj-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T}"><code>NLS_Solver.eval_nls_∇fobj</code></a></li><li><a href="#NLS_Solver.eval_nls_∇∇fobj-Tuple{AbstractMatrix{T} where T}"><code>NLS_Solver.eval_nls_∇∇fobj</code></a></li><li><a href="#NLS_Solver.eval_r-Tuple{AbstractNLS, AbstractVector{T} where T}"><code>NLS_Solver.eval_r</code></a></li><li><a href="#NLS_Solver.eval_r_J-Tuple{AbstractNLS, AbstractVector{T} where T}"><code>NLS_Solver.eval_r_J</code></a></li><li><a href="#NLS_Solver.initialize_x_Z-Tuple{AbstractArray, BoundConstraints}"><code>NLS_Solver.initialize_x_Z</code></a></li><li><a href="#NLS_Solver.iteration_count-Tuple{Abstract_Solver_Result}"><code>NLS_Solver.iteration_count</code></a></li><li><a href="#NLS_Solver.iteration_count-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.iteration_count</code></a></li><li><a href="#NLS_Solver.lower_bound-Tuple{BoundConstraints}"><code>NLS_Solver.lower_bound</code></a></li><li><a href="#NLS_Solver.multiplier_τ-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.multiplier_τ</code></a></li><li><a href="#NLS_Solver.objective_value-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.objective_value</code></a></li><li><a href="#NLS_Solver.objective_value-Tuple{Abstract_Solver_Result}"><code>NLS_Solver.objective_value</code></a></li><li><a href="#NLS_Solver.parameter_size-Tuple{AbstractNLS}"><code>NLS_Solver.parameter_size</code></a></li><li><a href="#NLS_Solver.project!-Union{Tuple{N}, Tuple{AbstractArray{var&quot;#s1&quot;, N} where var&quot;#s1&quot;&lt;:Real, BoundConstraints{var&quot;#s9&quot;, N, LBT, UBT} where {var&quot;#s9&quot;&lt;:Real, LBT&lt;:AbstractArray{var&quot;#s9&quot;, N}, UBT&lt;:AbstractArray{var&quot;#s9&quot;, N}}}} where N"><code>NLS_Solver.project!</code></a></li><li><a href="#NLS_Solver.quadratic_subproblem-Tuple{LinearAlgebra.Symmetric{var&quot;#s6&quot;, S} where {var&quot;#s6&quot;&lt;:Real, S&lt;:(AbstractMatrix{var&quot;#s814&quot;} where var&quot;#s814&quot;&lt;:var&quot;#s6&quot;)}, AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, BoundConstraints{var&quot;#s2&quot;, 1, LBT, UBT} where {var&quot;#s2&quot;&lt;:Real, LBT&lt;:AbstractVector{var&quot;#s2&quot;}, UBT&lt;:AbstractVector{var&quot;#s2&quot;}}, NLS_Solver.Abstract_BC_QuadSolver_Conf, NLS_Solver.LM_Damping, Int64}"><code>NLS_Solver.quadratic_subproblem</code></a></li><li><a href="#NLS_Solver.residue_size-Tuple{AbstractNLS}"><code>NLS_Solver.residue_size</code></a></li><li><a href="#NLS_Solver.restrict_to_inactive!-Tuple{LinearAlgebra.Symmetric, AbstractVector{T} where T, AbstractVector{NLS_Solver.BoundConstraint_Enum}, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, AbstractVector{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real}"><code>NLS_Solver.restrict_to_inactive!</code></a></li><li><a href="#NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_BC_Conf, Int64}"><code>NLS_Solver.set_max_iteration!</code></a></li><li><a href="#NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_Conf, Int64}"><code>NLS_Solver.set_max_iteration!</code></a></li><li><a href="#NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}"><code>NLS_Solver.set_ε_grad_Inf_norm!</code></a></li><li><a href="#NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}"><code>NLS_Solver.set_ε_grad_Inf_norm!</code></a></li><li><a href="#NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}"><code>NLS_Solver.set_ε_step_Inf_norm!</code></a></li><li><a href="#NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}"><code>NLS_Solver.set_ε_step_Inf_norm!</code></a></li><li><a href="#NLS_Solver.solution-Tuple{Abstract_Solver_Result}"><code>NLS_Solver.solution</code></a></li><li><a href="#NLS_Solver.solution-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.solution</code></a></li><li><a href="#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, Abstract_Solver_Conf}"><code>NLS_Solver.solve</code></a></li><li><a href="#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, BoundConstraints, Abstract_BC_Solver_Conf}"><code>NLS_Solver.solve</code></a></li><li><a href="#NLS_Solver.update_Z!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{NLS_Solver.BoundConstraint_Enum}, AbstractVector{T} where T, AbstractVector{T} where T}"><code>NLS_Solver.update_Z!</code></a></li><li><a href="#NLS_Solver.update_x!-Tuple{AbstractArray, AbstractArray{NLS_Solver.BoundConstraint_Enum, N} where N, BoundConstraints}"><code>NLS_Solver.update_x!</code></a></li><li><a href="#NLS_Solver.upper_bound-Tuple{BoundConstraints}"><code>NLS_Solver.upper_bound</code></a></li></ul><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><h3 id="Public"><a class="docs-heading-anchor" href="#Public">Public</a><a id="Public-1"></a><a class="docs-heading-anchor-permalink" href="#Public" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.AbstractNLS" href="#NLS_Solver.AbstractNLS"><code>NLS_Solver.AbstractNLS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractNLS end </code></pre><p>Defines an abstract non-linear least squares problem (NLS). In our context such problem is essentially a differentiable function <span>$\mathbf{r}$</span>:</p><p class="math-container">\[\mathbf{r}: \theta\in\mathbb{R}^{n_θ}\mapsto \mathbf{r}(\mathbf{\theta})\in\mathbb{R}^{n_S}\]</p><p>where:</p><ul><li><span>$\mathbf{r}(\mathbf{θ})∈\mathbb{R}^{n_S}$</span> is the residue vector,</li><li><span>$\mathbf{θ}∈\mathbb{R}^{n_θ}$</span> is the parameter vector to be optimized</li></ul><p>The objective function to minimize is:</p><p class="math-container">\[f(θ)=\frac{1}{2}\| \mathbf{r}(θ) \|^2\]</p><p>The classical approach uses a linear approximation of <span>$\mathbf{r}$</span>:</p><p class="math-container">\[\mathbf{r}(\mathbf{θ}+δ\mathbf{θ})\approx \mathbf{r}(\mathbf{θ}) + \mathbf{J}(\mathbf{θ})\cdot δ\mathbf{θ}\]</p><p>where <span>$\mathbf{J}$</span> is the Jacobian:</p><p class="math-container">\[\mathbf{J}_{i,j}=\partial_j r^i(\mathbf{θ}),\ i\in[1,n_S],\ j\in[1,n_θ]\]</p><p>This leads to</p><p class="math-container">\[f(\mathbf{θ}+δ\mathbf{θ})\approx f(\mathbf{θ}) + \langle \nabla f, δ\mathbf{θ} \rangle + \frac{1}{2}  \langle \nabla^2 f \cdot δ\mathbf{θ},  δ\mathbf{θ} \rangle\]</p><p>Where the gradient <span>$\nabla f$</span> is <span>$\mathbf{J}^t \mathbf{r}$</span> and the (approximate) Hessian <span>$\nabla^2 f$</span> is <span>$\mathbf{J}^t \mathbf{J}$</span>.</p><p>To implement such model, you must define the following functions:</p><ul><li><a href="#NLS_Solver.parameter_size-Tuple{AbstractNLS}"><code>parameter_size</code></a> : returns <span>$n_θ$</span></li><li><a href="#NLS_Solver.residue_size-Tuple{AbstractNLS}"><code>residue_size</code></a> : returns <span>$n_S$</span></li><li><a href="#NLS_Solver.eval_r-Tuple{AbstractNLS, AbstractVector{T} where T}"><code>eval_r</code></a> : compute <span>$\mathbf{r}$</span></li><li><a href="#NLS_Solver.eval_r_J-Tuple{AbstractNLS, AbstractVector{T} where T}"><code>eval_r_J</code></a> : compute <span>$(\mathbf{r}, \mathbf{J})$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls.jl#LL9-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.Abstract_BC_Solver_Conf" href="#NLS_Solver.Abstract_BC_Solver_Conf"><code>NLS_Solver.Abstract_BC_Solver_Conf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Abstract_BC_Solver_Conf end</code></pre><p>Abstract solver configuration. These are the solvers to be used to solve bound constrained nonlinear least squares:</p><p class="math-container">\[\min\limits_{\theta_l \le \theta \le \theta_u } \frac{1}{2}\|r(\theta)\|^2\]</p><p>Implementations:</p><ul><li><a href="#NLS_Solver.LevenbergMarquardt_BC_Conf"><code>LevenbergMarquardt_BC_Conf</code></a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_bc_solver_conf.jl#LL3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.Abstract_BC_Solver_Result" href="#NLS_Solver.Abstract_BC_Solver_Result"><code>NLS_Solver.Abstract_BC_Solver_Result</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The structure returned by <a href="#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, Abstract_Solver_Conf}"><code>solve</code></a> when using the <a href="#NLS_Solver.LevenbergMarquardt_BC_Conf"><code>LevenbergMarquardt_BC_Conf</code></a> method.</p><p>See <a href="#NLS_Solver.Abstract_Solver_Result"><code>Abstract_Solver_Result</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_bc_solver_result.jl#LL7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.Abstract_Solver_Conf" href="#NLS_Solver.Abstract_Solver_Conf"><code>NLS_Solver.Abstract_Solver_Conf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Abstract_Solver_Conf end</code></pre><p>Abstract solver configuration. These are the solvers to be used to solve unconstrained nonlinear least squares:</p><p class="math-container">\[\min\limits_\theta \frac{1}{2}\|r(\theta)\|^2\]</p><p>Implementations:</p><ul><li><a href="#NLS_Solver.LevenbergMarquardt_Conf"><code>LevenbergMarquardt_Conf</code></a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_solver_conf.jl#LL3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.Abstract_Solver_Result" href="#NLS_Solver.Abstract_Solver_Result"><code>NLS_Solver.Abstract_Solver_Result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Abstract_Solver_Result end</code></pre><p>This is the base type returned by the <a href="#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, Abstract_Solver_Conf}"><code>solve</code></a> method. It contains the information related to the founded solution.</p><p><strong>Interface</strong></p><ul><li><a href="#NLS_Solver.converged-Tuple{Abstract_Solver_Result}"><code>converged</code></a> </li><li><a href="#NLS_Solver.iteration_count-Tuple{Abstract_Solver_Result}"><code>iteration_count</code></a> </li><li><a href="#NLS_Solver.objective_value-Tuple{Abstract_Solver_Result}"><code>objective_value</code></a> </li><li><a href="#NLS_Solver.solution-Tuple{Abstract_Solver_Result}"><code>solution</code></a> </li></ul><p><strong>Implementations</strong></p><ul><li><a href="#NLS_Solver.LevenbergMarquardt_Result"><code>LevenbergMarquardt_Result</code></a> </li><li><a href="#NLS_Solver.LevenbergMarquardt_BC_Result"><code>LevenbergMarquardt_BC_Result</code></a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_solver_result.jl#LL6-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.BoundConstraints" href="#NLS_Solver.BoundConstraints"><code>NLS_Solver.BoundConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Store bound constraints <span>$[l,u]$</span></p><p>Presence of <code>NaN</code> component and the <span>$l\le u$</span> condition is checked at construction time. Note however that some components can be infinite.</p><p><strong>Constructors</strong></p><p>The following constructors are available:</p><ul><li>Construct <span>$[0.0,1.0]^n$</span> </li></ul><pre><code class="language-julia hljs">BoundConstraints(n)</code></pre><ul><li>Construct <span>$[T(0),T(1)]^n$</span> where components are of type <code>T</code></li></ul><pre><code class="language-julia hljs">BoundConstraints(T,n)</code></pre><ul><li>Construct <span>$[l,u]$</span> where <code>l</code> and <code>u</code> are lower and upper bound vectors</li></ul><pre><code class="language-julia hljs">BoundConstraints(l,u)</code></pre><p><strong>Related functions</strong></p><ul><li><a href="#Base.eltype-Union{Tuple{BoundConstraints{ELT, N, LBT, UBT} where {N, LBT&lt;:AbstractArray{ELT, N}, UBT&lt;:AbstractArray{ELT, N}}}, Tuple{ELT}} where ELT"><code>Base.eltype(bc::BoundConstraints{ELT}) where ELT</code></a> </li><li><a href="#Base.axes-Tuple{BoundConstraints}"><code>Base.axes(bc::BoundConstraints)</code></a> </li><li><a href="#Base.length-Tuple{BoundConstraints}"><code>Base.length(bc::BoundConstraints)</code></a> </li><li><a href="#Base.size-Tuple{BoundConstraints}"><code>Base.size(bc::BoundConstraints)</code></a> </li><li><a href="#Base.in-Union{Tuple{N}, Tuple{AbstractArray{var&quot;#s6&quot;, N} where var&quot;#s6&quot;&lt;:Real, BoundConstraints{var&quot;#s7&quot;, N, LBT, UBT} where {var&quot;#s7&quot;&lt;:Real, LBT&lt;:AbstractArray{var&quot;#s7&quot;, N}, UBT&lt;:AbstractArray{var&quot;#s7&quot;, N}}}} where N"><code>in(x::AbstractArray{&lt;:Real,N},bc::BoundConstraints{&lt;:Real,N}) where N</code></a> </li><li><a href="#NLS_Solver.lower_bound-Tuple{BoundConstraints}"><code>lower_bound(bc::BoundConstraints)</code></a> </li><li><a href="#NLS_Solver.upper_bound-Tuple{BoundConstraints}"><code>upper_bound(bc::BoundConstraints)</code></a> </li><li><a href="#NLS_Solver.project!-Union{Tuple{N}, Tuple{AbstractArray{var&quot;#s1&quot;, N} where var&quot;#s1&quot;&lt;:Real, BoundConstraints{var&quot;#s9&quot;, N, LBT, UBT} where {var&quot;#s9&quot;&lt;:Real, LBT&lt;:AbstractArray{var&quot;#s9&quot;, N}, UBT&lt;:AbstractArray{var&quot;#s9&quot;, N}}}} where N"><code>project!(x::AbstractArray{&lt;:Real,N},bc::BoundConstraints{&lt;:Real,N}) where N</code></a> </li><li><a href="#Base.:--Tuple{BoundConstraints, AbstractArray}"><code>Base.:-(bc::BoundConstraints,τ::AbstractArray)</code></a> </li><li><a href="#Base.:+-Tuple{BoundConstraints, AbstractArray}"><code>Base.:+(bc::BoundConstraints,τ::AbstractArray)</code></a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL7-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.LevenbergMarquardt_BC_Conf" href="#NLS_Solver.LevenbergMarquardt_BC_Conf"><code>NLS_Solver.LevenbergMarquardt_BC_Conf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct LevenbergMarquardt_BC_Conf &lt;: Abstract_Solver_Conf
    ...
end</code></pre><p>Use this constructor</p><pre><code class="language-julia hljs">LevenbergMarquardt_BC_Conf()</code></pre><p>to initialize the bound constrained Levenberg-Marquardt solver default configuration parameters.</p><p>To solve a problem with this method, you must then call  <a href="#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, BoundConstraints, Abstract_BC_Solver_Conf}"><code>solve(nls::AbstractNLS, θ_init::AbstractVector, bc::BoundConstraints, conf::Abstract_BC_Solver_Conf)</code></a> </p><p>See: </p><ul><li><a href="#NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_BC_Conf, Int64}"><code>set_max_iteration!(conf::LevenbergMarquardt_BC_Conf,max_iter::Int)</code></a> </li><li><a href="#NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}"><code>set_ε_grad_Inf_norm!(conf::LevenbergMarquardt_BC_Conf,ε_grad_Inf_norm::Float64)</code></a> </li><li><a href="#NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}"><code>set_ε_step_Inf_norm!(conf::LevenbergMarquardt_BC_Conf,ε_step_Inf_norm::Float64)</code></a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm_bc.jl#LL251-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.LevenbergMarquardt_BC_Result" href="#NLS_Solver.LevenbergMarquardt_BC_Result"><code>NLS_Solver.LevenbergMarquardt_BC_Result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LevenbergMarquardt_BC_Result{T&lt;:Real} &lt;:  Abstract_BC_Solver_Result
    ...
end </code></pre><p>This structure subtypes <a href="#NLS_Solver.Abstract_BC_Solver_Result"><code>Abstract_BC_Solver_Result</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm_bc_result.jl#LL3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.LevenbergMarquardt_Conf" href="#NLS_Solver.LevenbergMarquardt_Conf"><code>NLS_Solver.LevenbergMarquardt_Conf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct LevenbergMarquardt_Conf &lt;: Abstract_Solver_Conf
    ...
end</code></pre><p>Use this constructor</p><pre><code class="language-julia hljs">LevenbergMarquardt_Conf()</code></pre><p>to initialize the Levenberg-Marquardt solver default configuration parameters.</p><p>To solve a problem with this method, you must then call  <a href="#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, Abstract_Solver_Conf}"><code>solve(nls::AbstractNLS, θ_init::AbstractVector, conf::Abstract_Solver_Conf)</code></a> </p><p>See: </p><ul><li><a href="#NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_Conf, Int64}"><code>set_max_iteration!(conf::LevenbergMarquardt_Conf,max_iter::Int)</code></a> </li><li><a href="#NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}"><code>set_ε_grad_Inf_norm!(conf::LevenbergMarquardt_Conf,ε_grad_Inf_norm::Float64)</code></a> </li><li><a href="#NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}"><code>set_ε_step_Inf_norm!(conf::LevenbergMarquardt_Conf,ε_step_Inf_norm::Float64)</code></a> </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm.jl#LL168-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.LevenbergMarquardt_Result" href="#NLS_Solver.LevenbergMarquardt_Result"><code>NLS_Solver.LevenbergMarquardt_Result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LevenbergMarquardt_Result{T&lt;:Real} &lt;: Abstract_Solver_Result
   ...
end</code></pre><p>This structure subtypes <a href="#NLS_Solver.Abstract_Solver_Result"><code>Abstract_Solver_Result</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm_result.jl#LL3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.NLS_ForwardDiff" href="#NLS_Solver.NLS_ForwardDiff"><code>NLS_Solver.NLS_ForwardDiff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct NLS_ForwardDiff &lt;: AbstractNLS
    ...
end
</code></pre><p>A specialization that uses the <code>ForwardDiff</code> package to compute the Jacobian.</p><p>By comparison with <a href="#NLS_Solver.AbstractNLS"><code>AbstractNLS</code></a> you only have to define these functions:</p><ul><li><a href="#NLS_Solver.parameter_size-Tuple{AbstractNLS}"><code>parameter_size</code></a> : returns <span>$n_θ$</span></li><li><a href="#NLS_Solver.residue_size-Tuple{AbstractNLS}"><code>residue_size</code></a> : returns <span>$n_S$</span></li><li><a href="#NLS_Solver.eval_r-Tuple{AbstractNLS, AbstractVector{T} where T}"><code>eval_r</code></a> : computation of <span>$\mathbf{r}$</span></li></ul><p>See: <a href="#NLS_Solver.create_NLS_problem_using_ForwardDiff-Tuple{Function, Pair{Int64, Int64}}"><code>create_NLS_problem_using_ForwardDiff</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls_forwarddiff.jl#LL5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.converged-Tuple{Abstract_Solver_Result}" href="#NLS_Solver.converged-Tuple{Abstract_Solver_Result}"><code>NLS_Solver.converged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">converged(::Abstract_Solver_Result)</code></pre><p>Return <code>true</code> if the solver converged</p><p>See: <a href="#NLS_Solver.Abstract_Solver_Result"><code>Abstract_Solver_Result</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_solver_result.jl#LL27-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.converged-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}" href="#NLS_Solver.converged-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.converged</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">converged(::Abstract_BC_QuadSolver_Result)</code></pre><p>Return <code>true</code> if the solver converged</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/abstract_bc_quadsolver_result.jl#LL10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.create_NLS_problem_using_ForwardDiff-Tuple{Function, Pair{Int64, Int64}}" href="#NLS_Solver.create_NLS_problem_using_ForwardDiff-Tuple{Function, Pair{Int64, Int64}}"><code>NLS_Solver.create_NLS_problem_using_ForwardDiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_NLS_problem_using_ForwardDiff(r::Function;domain_image_dim::Pair{Int,Int})</code></pre><p>Creates an <a href="#NLS_Solver.AbstractNLS"><code>AbstractNLS</code></a> specialized instance where the <a href="#NLS_Solver.eval_r_J-Tuple{AbstractNLS, AbstractVector{T} where T}"><code>eval_r_J</code></a> function is automatically defined using automatic differentiation.</p><ul><li><code>r</code> is a function that maps a parameter vector θ to its residue. The Jacobian matrix is computed using the <code>ForwardDiff</code> package.</li><li><code>domain_image_dim</code> is a pair of the form <code>θ length =&gt; r length</code> that defines domain and codomain dimensions.</li></ul><p><strong>Usage example</strong></p><p>An example defining the Rosenbrock function</p><p class="math-container">\[\frac{1}{2}\|r(\theta)\|^2\text{ where }r = \sqrt{2} \left( \begin{array}{c}  1-\theta_1 \\ 10(\theta_2-\theta_1^2) \end{array} \right)\]</p><pre><code class="language-julia hljs">nls = create_NLS_problem_using_ForwardDiff(2 =&gt; 2) do θ
     sqrt(2) sqrt(2)* [ 1-θ[1], 10*(θ[2]-θ[1]^2) ]* [ 1-θ[1], 10*(θ[2]-θ[1]^2) ]
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls_forwarddiff.jl#LL30-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.eval_nls_fobj-Tuple{AbstractVector{T} where T}" href="#NLS_Solver.eval_nls_fobj-Tuple{AbstractVector{T} where T}"><code>NLS_Solver.eval_nls_fobj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_nls_fobj(r::AbstractVector{T}) -&gt; f(θ)</code></pre><p>Compute <span>$f(θ)=\frac{1}{2}\| \mathbf{r}(\mathbf{θ}) \|^2$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls.jl#LL98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.eval_nls_∇fobj-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T}" href="#NLS_Solver.eval_nls_∇fobj-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T}"><code>NLS_Solver.eval_nls_∇fobj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_nls_∇fobj(r,J) -&gt; ∇fobj</code></pre><p>Compute the gradient: <span>$\nabla f(\mathbf{θ}) = \mathbf{J}^t\mathbf{r}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls.jl#LL107-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.eval_nls_∇∇fobj-Tuple{AbstractMatrix{T} where T}" href="#NLS_Solver.eval_nls_∇∇fobj-Tuple{AbstractMatrix{T} where T}"><code>NLS_Solver.eval_nls_∇∇fobj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_nls_∇∇fobj(J) -&gt; ∇∇fobj</code></pre><p>Compute the (approximate) Hessian: <span>$\nabla^2 f(\mathbf{θ}) = \mathbf{J}^t\mathbf{J}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls.jl#LL118-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.eval_r-Tuple{AbstractNLS, AbstractVector{T} where T}" href="#NLS_Solver.eval_r-Tuple{AbstractNLS, AbstractVector{T} where T}"><code>NLS_Solver.eval_r</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_r(nls::AbstractNLS,
        θ::AbstractVector) -&gt; r</code></pre><p>Compte the residual vector <span>$\mathbf{r}$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls.jl#LL72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.eval_r_J-Tuple{AbstractNLS, AbstractVector{T} where T}" href="#NLS_Solver.eval_r_J-Tuple{AbstractNLS, AbstractVector{T} where T}"><code>NLS_Solver.eval_r_J</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eval_r_J(nls::AbstractNLS,θ::AbstractVector) -&gt; (r,J)</code></pre><p>Compute the residual the vector <span>$\mathbf{r}$</span> and its Jacobian <span>$\mathbf{J}$</span> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls.jl#LL83-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.iteration_count-Tuple{Abstract_Solver_Result}" href="#NLS_Solver.iteration_count-Tuple{Abstract_Solver_Result}"><code>NLS_Solver.iteration_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iteration_count(::Abstract_Solver_Result)</code></pre><p>Return the number of consumed iteration</p><p>See: <a href="#NLS_Solver.Abstract_Solver_Result"><code>Abstract_Solver_Result</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_solver_result.jl#LL37-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.iteration_count-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}" href="#NLS_Solver.iteration_count-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.iteration_count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iteration_count(::Abstract_BC_QuadSolver_Result)</code></pre><p>Return the number of consumed iteration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/abstract_bc_quadsolver_result.jl#LL17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.lower_bound-Tuple{BoundConstraints}" href="#NLS_Solver.lower_bound-Tuple{BoundConstraints}"><code>NLS_Solver.lower_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lower_bound(bc::BoundConstraints)</code></pre><p>Return lower bound <code>l</code></p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.objective_value-Tuple{Abstract_Solver_Result}" href="#NLS_Solver.objective_value-Tuple{Abstract_Solver_Result}"><code>NLS_Solver.objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective_value(::Abstract_Solver_Result)</code></pre><p>Returns objective value at the point <a href="#NLS_Solver.solution-Tuple{Abstract_Solver_Result}"><code>solution</code></a>.</p><p>See: <a href="#NLS_Solver.Abstract_Solver_Result"><code>Abstract_Solver_Result</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_solver_result.jl#LL48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.objective_value-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}" href="#NLS_Solver.objective_value-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.objective_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">objective_value(::Abstract_BC_QuadSolver_Result)</code></pre><p>Returns objective value at the point <a href="#NLS_Solver.solution-Tuple{Abstract_Solver_Result}"><code>solution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/abstract_bc_quadsolver_result.jl#LL25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.parameter_size-Tuple{AbstractNLS}" href="#NLS_Solver.parameter_size-Tuple{AbstractNLS}"><code>NLS_Solver.parameter_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameter_size(nls::AbstractNLS)</code></pre><p>Return the dimension <span>$n_θ$</span> of the parameter vector <span>$θ$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls.jl#LL58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.project!-Union{Tuple{N}, Tuple{AbstractArray{var&quot;#s1&quot;, N} where var&quot;#s1&quot;&lt;:Real, BoundConstraints{var&quot;#s9&quot;, N, LBT, UBT} where {var&quot;#s9&quot;&lt;:Real, LBT&lt;:AbstractArray{var&quot;#s9&quot;, N}, UBT&lt;:AbstractArray{var&quot;#s9&quot;, N}}}} where N" href="#NLS_Solver.project!-Union{Tuple{N}, Tuple{AbstractArray{var&quot;#s1&quot;, N} where var&quot;#s1&quot;&lt;:Real, BoundConstraints{var&quot;#s9&quot;, N, LBT, UBT} where {var&quot;#s9&quot;&lt;:Real, LBT&lt;:AbstractArray{var&quot;#s9&quot;, N}, UBT&lt;:AbstractArray{var&quot;#s9&quot;, N}}}} where N"><code>NLS_Solver.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(x::AbstractArray{&lt;:Real,N},bc::BoundConstraints{&lt;:Real,N})</code></pre><p>Project <code>x</code> such that <span>$x \in [l,u]$</span> is fullfiled.</p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.residue_size-Tuple{AbstractNLS}" href="#NLS_Solver.residue_size-Tuple{AbstractNLS}"><code>NLS_Solver.residue_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_size(nls::AbstractNLS)</code></pre><p>Return the dimension <span>$n_S$</span> of the residue vector <span>$r$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_nls.jl#LL65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_BC_Conf, Int64}" href="#NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_BC_Conf, Int64}"><code>NLS_Solver.set_max_iteration!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_max_iteration!(conf::LevenbergMarquardt_BC_Conf,
                   max_iter::Int)</code></pre><p>Modify the maximum number of iterations</p><p>See: <a href="#NLS_Solver.LevenbergMarquardt_BC_Conf"><code>LevenbergMarquardt_BC_Conf</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm_bc.jl#LL302-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_Conf, Int64}" href="#NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_Conf, Int64}"><code>NLS_Solver.set_max_iteration!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_max_iteration!(conf::LevenbergMarquardt_Conf,
                   max_iter::Int)</code></pre><p>Modify the maximum number of iterations</p><p>See: <a href="#NLS_Solver.LevenbergMarquardt_Conf"><code>LevenbergMarquardt_Conf</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm.jl#LL224-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}" href="#NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}"><code>NLS_Solver.set_ε_grad_Inf_norm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_ε_grad_Inf_norm!(conf::LevenbergMarquardt_BC_Conf,
                     ε_grad_Inf_norm::Float64)</code></pre><p>Modify the stopping criterion <span>$|\nabla f|_\infty\le\epsilon$</span></p><p>See: <a href="#NLS_Solver.LevenbergMarquardt_BC_Conf"><code>LevenbergMarquardt_BC_Conf</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm_bc.jl#LL316-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}" href="#NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}"><code>NLS_Solver.set_ε_grad_Inf_norm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_ε_grad_Inf_norm!(conf::LevenbergMarquardt_Conf,
                     ε_grad_Inf_norm::Float64)</code></pre><p>Modify the stopping criterion <span>$|\nabla f|_\infty\le\epsilon$</span></p><p>See: <a href="#NLS_Solver.LevenbergMarquardt_Conf"><code>LevenbergMarquardt_Conf</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm.jl#LL240-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}" href="#NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}"><code>NLS_Solver.set_ε_step_Inf_norm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_ε_step_Inf_norm!(conf::LevenbergMarquardt_BC_Conf,
                     ε_step_Inf_norm::Float64)</code></pre><p>Modify the stopping criterion <span>$|\delta x|_\infty\le\epsilon$</span></p><p>See: <a href="#NLS_Solver.LevenbergMarquardt_BC_Conf"><code>LevenbergMarquardt_BC_Conf</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm_bc.jl#LL330-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}" href="#NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}"><code>NLS_Solver.set_ε_step_Inf_norm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_ε_step_Inf_norm!(conf::LevenbergMarquardt_Conf,
                     ε_step_Inf_norm::Float64)</code></pre><p>Modify the stopping criterion <span>$|\delta x|_\infty\le\epsilon$</span></p><p>See: <a href="#NLS_Solver.LevenbergMarquardt_Conf"><code>LevenbergMarquardt_Conf</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm.jl#LL256-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.solution-Tuple{Abstract_Solver_Result}" href="#NLS_Solver.solution-Tuple{Abstract_Solver_Result}"><code>NLS_Solver.solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution(::Abstract_Solver_Result)</code></pre><p>Returns the founded solution </p><p>See: <a href="#NLS_Solver.Abstract_Solver_Result"><code>Abstract_Solver_Result</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/abstract_solver_result.jl#LL58-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.solution-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}" href="#NLS_Solver.solution-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solution(::Abstract_BC_QuadSolver_Result)</code></pre><p>Returns the founded solution </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/abstract_bc_quadsolver_result.jl#LL39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, Abstract_Solver_Conf}" href="#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, Abstract_Solver_Conf}"><code>NLS_Solver.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(nls::AbstractNLS,
      θ_init::AbstractVector,
      conf::Abstract_Solver_Conf)::Abstract_Solver_Result</code></pre><p>Generic interface to solve an <a href="#NLS_Solver.AbstractNLS"><code>AbstractNLS</code></a> problem.</p><p>The used algorithm is defined through <a href="#NLS_Solver.Abstract_Solver_Conf"><code>Abstract_Solver_Conf</code></a> specializations.</p><p>The method returns a <a href="#NLS_Solver.Abstract_Solver_Result"><code>Abstract_Solver_Result</code></a> specialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/solver_interface.jl#LL3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, BoundConstraints, Abstract_BC_Solver_Conf}" href="#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, BoundConstraints, Abstract_BC_Solver_Conf}"><code>NLS_Solver.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(nls::AbstractNLS,
      θ_init::AbstractVector,
      bc::BoundConstraints,
      conf::Abstract_BC_Solver_Conf) -&gt; Abstract_Solver_Result</code></pre><p>Generic interface to solve a <a href="#NLS_Solver.AbstractNLS"><code>AbstractNLS</code></a> problem <strong>with bound constraints</strong>.</p><p>The used algorithm is defined through <a href="#NLS_Solver.Abstract_BC_Solver_Conf"><code>Abstract_BC_Solver_Conf</code></a> specializations.</p><p>The method returns a <a href="#NLS_Solver.Abstract_BC_Solver_Result"><code>Abstract_BC_Solver_Result</code></a> specialization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bc_solver_interface.jl#LL3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.upper_bound-Tuple{BoundConstraints}" href="#NLS_Solver.upper_bound-Tuple{BoundConstraints}"><code>NLS_Solver.upper_bound</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">upper_bound(bc::BoundConstraints)</code></pre><p>Return upper bound <code>u</code></p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL121-L127">source</a></section></article><h3 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.Abstract_BC_QuadSolver_Result" href="#NLS_Solver.Abstract_BC_QuadSolver_Result"><code>NLS_Solver.Abstract_BC_QuadSolver_Result</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Abstract_BC_QuadSolver_Result end</code></pre><p>Quadratic solver result abstraction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/abstract_bc_quadsolver_result.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.BoundConstraint_Enum" href="#NLS_Solver.BoundConstraint_Enum"><code>NLS_Solver.BoundConstraint_Enum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum(BoundConstraint_Enum,
      ACTIVE_LB = -1,
      INACTIVE_BC = 0,
      ACTIVE_UB = +1)</code></pre><p>An enum to store bound constraint state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/boundconstraint_enum.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{BoundConstraints, AbstractArray}" href="#Base.:+-Tuple{BoundConstraints, AbstractArray}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:+(bc::BoundConstraints,τ::AbstractArray)</code></pre><p>Translate bound constraints</p><p class="math-container">\[[a+τ,b+τ] = [a,b]+τ\]</p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL166-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{BoundConstraints, AbstractArray}" href="#Base.:--Tuple{BoundConstraints, AbstractArray}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.:-(bc::BoundConstraints,τ::AbstractArray)</code></pre><p>Translate bound constraints</p><p class="math-container">\[[a-τ,b-τ] = [a,b]-τ\]</p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL152-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.axes-Tuple{BoundConstraints}" href="#Base.axes-Tuple{BoundConstraints}"><code>Base.axes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">axes(bc::BoundConstraints)</code></pre><p>Return bound axes</p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{BoundConstraints{ELT, N, LBT, UBT} where {N, LBT&lt;:AbstractArray{ELT, N}, UBT&lt;:AbstractArray{ELT, N}}}, Tuple{ELT}} where ELT" href="#Base.eltype-Union{Tuple{BoundConstraints{ELT, N, LBT, UBT} where {N, LBT&lt;:AbstractArray{ELT, N}, UBT&lt;:AbstractArray{ELT, N}}}, Tuple{ELT}} where ELT"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eltype(bc::BoundConstraints)</code></pre><p>Return bound element type</p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL64-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Union{Tuple{N}, Tuple{AbstractArray{var&quot;#s6&quot;, N} where var&quot;#s6&quot;&lt;:Real, BoundConstraints{var&quot;#s7&quot;, N, LBT, UBT} where {var&quot;#s7&quot;&lt;:Real, LBT&lt;:AbstractArray{var&quot;#s7&quot;, N}, UBT&lt;:AbstractArray{var&quot;#s7&quot;, N}}}} where N" href="#Base.in-Union{Tuple{N}, Tuple{AbstractArray{var&quot;#s6&quot;, N} where var&quot;#s6&quot;&lt;:Real, BoundConstraints{var&quot;#s7&quot;, N, LBT, UBT} where {var&quot;#s7&quot;&lt;:Real, LBT&lt;:AbstractArray{var&quot;#s7&quot;, N}, UBT&lt;:AbstractArray{var&quot;#s7&quot;, N}}}} where N"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">in(bc::BoundConstraints)</code></pre><p>Check if <span>$x\in [l,u]$</span></p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{BoundConstraints}" href="#Base.length-Tuple{BoundConstraints}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(bc::BoundConstraints)</code></pre><p>Return bound length</p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{BoundConstraints}" href="#Base.size-Tuple{BoundConstraints}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(bc::BoundConstraints)</code></pre><p>Return bound size</p><p>See: <a href="#NLS_Solver.BoundConstraints"><code>BoundConstraints</code></a> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/bound_constraints.jl#LL92-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.check_first_order-Tuple{AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, BoundConstraints{var&quot;#s2&quot;, 1, LBT, UBT} where {var&quot;#s2&quot;&lt;:Real, LBT&lt;:AbstractVector{var&quot;#s2&quot;}, UBT&lt;:AbstractVector{var&quot;#s2&quot;}}}" href="#NLS_Solver.check_first_order-Tuple{AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, BoundConstraints{var&quot;#s2&quot;, 1, LBT, UBT} where {var&quot;#s2&quot;&lt;:Real, LBT&lt;:AbstractVector{var&quot;#s2&quot;}, UBT&lt;:AbstractVector{var&quot;#s2&quot;}}}"><code>NLS_Solver.check_first_order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_first_order(∇f::AbstractVector{&lt;:Real},
                  xstar::AbstractVector{&lt;:Real},
                  bc::BoundConstraints{&lt;:Real,1})

check_first_order(Q::Symmetric{&lt;:Real},
                  q::AbstractVector{&lt;:Real},
                  xstar::AbstractVector{&lt;:Real},
                  bc::BoundConstraints{&lt;:Real,1})</code></pre><p>Check First-Order Conditions  (see <a href="https://wiki.mcs.anl.gov/leyffer/images/0/01/07-bndCons.pdf">Bound Constrained Optimization slides</a>)</p><p>If <span>$x^\star=\arg\min f(x), x\in[l,u]$</span> then:</p><p class="math-container">\[\partial_i f(x^\star) = \left\{\begin{array}{ll}
\ge 0, &amp; \text{if } x^\star[i] = l[i] \\
= 0, &amp; \text{if } l[i] \le x^\star[i] \le u[i] \\
\le 0, &amp; \text{if } x^\star[i] = u[i] \\
\end{array}
\right.\]</p><p>This is equivalent to:</p><p class="math-container">\[x^\star = P_{[l,u]}(x^\star-\nabla f(x^\star))\]</p><p>According to the previous result, this function returns:</p><p class="math-container">\[\max \mid x^\star - P_{[l,u]}(x^\star-(Q.x^\star+q)) \mid\]</p><p>For a local stationary point this quantity must be null </p><p>The second function is a wrapper that computes <span>$∇f=Q.x^\star+q$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/misc.jl#LL5-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.clean_τ!-Tuple{AbstractArray{var&quot;#s9&quot;, N} where {var&quot;#s9&quot;&lt;:Real, N}, AbstractArray{NLS_Solver.BoundConstraint_Enum, N} where N}" href="#NLS_Solver.clean_τ!-Tuple{AbstractArray{var&quot;#s9&quot;, N} where {var&quot;#s9&quot;&lt;:Real, N}, AbstractArray{NLS_Solver.BoundConstraint_Enum, N} where N}"><code>NLS_Solver.clean_τ!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clean_τ!(τ::AbstractArray{&lt;:Real},              
         Z::AbstractArray{BoundConstraint_Enum})</code></pre><p>By definition τ=-Qx-q. If the algorithm converged, then one must have τ[i]=0 when the constraint is inactive.</p><p>This function updates τ by overwriting τ[i]=0 when Z[i]=inactive. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/Kunisch-Rendl.jl#LL273-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.compute_δL_constrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T, AbstractVector{T} where T}" href="#NLS_Solver.compute_δL_constrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T, AbstractVector{T} where T}"><code>NLS_Solver.compute_δL_constrained</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Same idea than <a href="#NLS_Solver.compute_δL_unconstrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T}"><code>compute_δL_unconstrained</code></a>, however when bound constraints are present <span>$h$</span> is such that:</p><p class="math-container">\[(\nabla^2 f + \mu I)h + \nabla f + \tau = 0\]</p><p>it follows that:</p><p class="math-container">\[δL = L(0)-L(h) = \frac{1}{2} \langle h, \mu h + \tau - \nabla f \rangle\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/rho.jl#LL42-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.compute_δL_unconstrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T}" href="#NLS_Solver.compute_δL_unconstrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T}"><code>NLS_Solver.compute_δL_unconstrained</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute δL = L(0)-L(h) where L is the quadratic model</p><p class="math-container">\[L(h)=f(\theta) + \langle \nabla f, h \rangle + \frac{1}{2}\langle \nabla^2 f h, h \rangle\]</p><p>with <span>$f(\theta)=\frac{1}{2}\| r(θ) \|_2^2$</span>, <span>$\nabla f = J^t r$</span> and <span>$\nabla^2 f = J^t J$</span></p><p>A direct computation gives:</p><p class="math-container">\[δL = L(0)-L(h) = -\left(  \langle J^tr, h \rangle + \frac{1}{2}\langle \nabla^2 f h, h \rangle \right)\]</p><p>However one can avoid the computation of <span>$\nabla^2 f h$</span> if one uses the fact that <span>$h$</span> is solution of:</p><p class="math-container">\[(\nabla^2 f + \mu I)h + \nabla f = 0\]</p><p>With this hypothesis, one gets:</p><p class="math-container">\[δL = L(0)-L(h) = \frac{1}{2} \langle h, \mu h - \nabla f \rangle\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/rho.jl#LL2-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.compute_δf-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}" href="#NLS_Solver.compute_δf-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}"><code>NLS_Solver.compute_δf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute true variation of the real model: <span>$δf = \frac{1}{2}(r^t(θ)r(θ)-r^t(θ+h)r(θ+h))$</span></p><p>Contrary to <span>$δL$</span> things are simpler. However a trick is to use an equivalent formulation:</p><p class="math-container">\[δf = \frac{1}{2}(r^t(θ)r(θ)-r^t(θ+h)r(θ+h)) = \frac{1}{2}(r(θ)-r(θ+h))^t(r(θ)+r(θ+h))\]</p><p>that has a better numerical behavior. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/rho.jl#LL64-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.initialize_x_Z-Tuple{AbstractArray, BoundConstraints}" href="#NLS_Solver.initialize_x_Z-Tuple{AbstractArray, BoundConstraints}"><code>NLS_Solver.initialize_x_Z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialize_x_Z(x_init::AbstractArray,
               bc::BoundConstraints)</code></pre><p>Create (x,Z) from initial guess <code>x_init</code> and bound constraints <code>bc</code></p><p><code>Z</code> is created by recording how <code>x_init</code> fulfils the bound constraints <code>bc</code>.</p><p><code>x</code> is the projection of <code>x_init</code> on the bounded domain [l,b].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/Kunisch-Rendl.jl#LL193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.multiplier_τ-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}" href="#NLS_Solver.multiplier_τ-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}"><code>NLS_Solver.multiplier_τ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiplier_τ(::Abstract_BC_QuadSolver_Result)</code></pre><p>Returns the multipliers stored in a compact form (see τ definition, TODO)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/abstract_bc_quadsolver_result.jl#LL32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.quadratic_subproblem-Tuple{LinearAlgebra.Symmetric{var&quot;#s6&quot;, S} where {var&quot;#s6&quot;&lt;:Real, S&lt;:(AbstractMatrix{var&quot;#s814&quot;} where var&quot;#s814&quot;&lt;:var&quot;#s6&quot;)}, AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, BoundConstraints{var&quot;#s2&quot;, 1, LBT, UBT} where {var&quot;#s2&quot;&lt;:Real, LBT&lt;:AbstractVector{var&quot;#s2&quot;}, UBT&lt;:AbstractVector{var&quot;#s2&quot;}}, NLS_Solver.Abstract_BC_QuadSolver_Conf, NLS_Solver.LM_Damping, Int64}" href="#NLS_Solver.quadratic_subproblem-Tuple{LinearAlgebra.Symmetric{var&quot;#s6&quot;, S} where {var&quot;#s6&quot;&lt;:Real, S&lt;:(AbstractMatrix{var&quot;#s814&quot;} where var&quot;#s814&quot;&lt;:var&quot;#s6&quot;)}, AbstractVector{var&quot;#s5&quot;} where var&quot;#s5&quot;&lt;:Real, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, BoundConstraints{var&quot;#s2&quot;, 1, LBT, UBT} where {var&quot;#s2&quot;&lt;:Real, LBT&lt;:AbstractVector{var&quot;#s2&quot;}, UBT&lt;:AbstractVector{var&quot;#s2&quot;}}, NLS_Solver.Abstract_BC_QuadSolver_Conf, NLS_Solver.LM_Damping, Int64}"><code>NLS_Solver.quadratic_subproblem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Solve</p><p class="math-container">\[\min\limits_{h∈[θ^l-θ,θ^u-θ]}\frac{1}{2}h^t.(H+μI).h + ∇f^t.h\]</p><p>We use the quadratic model of <span>$f$</span>, the bound contraints are such that the step <span>$h$</span> makes the update <span>$x+h$</span> falls in the <span>$[θ^l,θ^u]$</span> bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/Levenberg-Marquardt/lm_bc.jl#LL18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.restrict_to_inactive!-Tuple{LinearAlgebra.Symmetric, AbstractVector{T} where T, AbstractVector{NLS_Solver.BoundConstraint_Enum}, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, AbstractVector{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real}" href="#NLS_Solver.restrict_to_inactive!-Tuple{LinearAlgebra.Symmetric, AbstractVector{T} where T, AbstractVector{NLS_Solver.BoundConstraint_Enum}, AbstractVector{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:Real, AbstractVector{var&quot;#s2&quot;} where var&quot;#s2&quot;&lt;:Real}"><code>NLS_Solver.restrict_to_inactive!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restrict_to_inactive!(Q::Symmetric,
                      q::AbstractVector,
                      Z::AbstractVector{BoundConstraint_Enum},
                      lb::AbstractVector{&lt;:Real},
                      ub::AbstractVector{&lt;:Real})</code></pre><pre><code class="language-julia hljs">function restrict_to_inactive!(Q::Symmetric,
                               q::AbstractVector,
                               Z::AbstractVector{BoundConstraint_Enum},
                               bc::BoundConstraints{&lt;:Real,1})</code></pre><p>In-place modification of <span>$(Q,q)$</span> that produces <span>$(\tilde{Q},\tilde{q})$</span> such that the initial optimization problem:</p><p class="math-container">\[\tilde{x} = \arg\min \frac{1}{2} x^t Q x + q^tx\]</p><p>under these constraints:</p><p class="math-container">\[x[i] = \left\{\begin{array}{ll} 
l[i], &amp; \text{if } Z[i] = -1 \\
u[i], &amp; \text{if } Z[i] = +1 
\end{array}\right.\]</p><p>is transformed into this linear system:</p><p class="math-container">\[\tilde{Q}\tilde{x}+\tilde{q}=0\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/Kunisch-Rendl.jl#LL3-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.update_Z!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{NLS_Solver.BoundConstraint_Enum}, AbstractVector{T} where T, AbstractVector{T} where T}" href="#NLS_Solver.update_Z!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{NLS_Solver.BoundConstraint_Enum}, AbstractVector{T} where T, AbstractVector{T} where T}"><code>NLS_Solver.update_Z!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_Z!(x::AbstractVector,
          τ::AbstractVector,
          Z::AbstractVector{BoundConstraint_Enum},
          lb::AbstractVector,
          ub::AbstractVector)</code></pre><pre><code class="language-julia hljs">update_Z!(x::AbstractVector,
          τ::AbstractVector,
          Z::AbstractVector{BoundConstraint_Enum},
          bc::BoundConstraints{&lt;:Real,1})</code></pre><p>This function updates <code>Z</code> according to <code>x</code>, <code>τ</code> and bounds <code>lb</code>, <code>ub</code> values.</p><p>It also count how many changes have be done during this update.</p><p>No change means that the algorithm has converged.</p><p><strong>Note:</strong> this function only modifies <code>Z</code> and return the number of bad hypothesis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/Kunisch-Rendl.jl#LL108-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NLS_Solver.update_x!-Tuple{AbstractArray, AbstractArray{NLS_Solver.BoundConstraint_Enum, N} where N, BoundConstraints}" href="#NLS_Solver.update_x!-Tuple{AbstractArray, AbstractArray{NLS_Solver.BoundConstraint_Enum, N} where N, BoundConstraints}"><code>NLS_Solver.update_x!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_x!(x::AbstractArray,
          Z::AbstractArray{BoundConstraint_Enum},
          bc::BoundConstraints)</code></pre><p>Update x value such that:</p><p class="math-container">\[x[i] = \left\{\begin{array}{ll} 
l[i], &amp; \text{if } Z[i] = -1 \\
u[i], &amp; \text{if } Z[i] = +1 
\end{array}\right.\]</p><p>When <span>$Z[i]=0$</span> the <span>$x[i]$</span> value is unaffected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vincent-picaud/NLS_Solver.jl/blob/a51729dd16f67868cc3de4c612a7257b6b998d94/src/QuadSolvers/Kunisch-Rendl.jl#LL236-L251">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nonlinear_regressions/">« Nonlinear regressions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 30 December 2021 20:50">Thursday 30 December 2021</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
