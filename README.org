#+options: H:3 toc:t \n:nil ::t |:t ^:{} -:t f:t *:t tex:t d:t tags:not-in-toc
#+title: NLS_Solver.jl
#+property: header-args:julia :results output :exports code :eval no-export

[[https://vincent-picaud.github.io/NLS_Solver.jl/stable][file:https://img.shields.io/badge/docs-stable-blue.svg]] [[https://vincent-picaud.github.io/NLS_Solver.jl/stable][file:https://img.shields.io/badge/docs-stable-blue.svg]] [[https://github.com/vincent-picaud/NLS_Solver.jl/actions][file:https://github.com/vincent-picaud/NLS_Solver.jl/workflows/CI/badge.svg]]
[[https://codecov.io/gh/vincent-picaud/NLS_Solver.jl][file:https://codecov.io/gh/vincent-picaud/NLS_Solver.jl/branch/main/graph/badge.svg]]


* Table of contents                                            :TOC:noexport:
- [[#what-is-it][What is it?]]
  - [[#references][References]]
- [[#getting-started][Getting started]]
  - [[#wrap-the-problem][Wrap the problem]]
  - [[#chose-an-algorithm][Chose an algorithm]]

* What is it?

This is a Julia package used to solve bound constrained non-linear squares:

[[file:figures/eq_bc_pb.png][file:figures/eq_bc_pb.png]]

# \begin{align*}
# \min\limits_\theta & \frac{1}{2}\|r(\theta)\|^2 \\
#      & \theta_l \le \theta \le \theta_u 
# \end{align*}

The implemented algorithm is a variation of the classical
Levenberg-Marquardt algorithm where the bound constrained problem is
solved by the Kunisch method.

Please note that there is also a dedicated function to solve unconstrained NLS:

[[file:figures/eq_pb.png][file:figures/eq_pb.png]]

# \begin{equation*}
# \min\limits_\theta & \frac{1}{2}\|r(\theta)\|^2
# \end{equation*}

** References

The most useful references concerning implemented method are given below.

*** Nonlinear least squares

The first reference is a must read about nonlinear least squares algorithms. 

- Madsen, N. (). Methods For Non-Linear Least Squares Problems.
  http://www2.imm.dtu.dk/pubdb/edoc/imm3215.pdf

The second reference provides some details about damping parameter. It
also also gives an useful list of test functions (unconstrained case).

- Nielsen, H. B., & others, (1999). Damping parameter in marquardt's
  method. : IMM.
  http://www2.imm.dtu.dk/documents/ftp/tr99/tr05_99.pdf

*** Bound constrained quadratic problem

This reference presents a method to solve quadratic problems with
unilateral bound constraints. The generalization to bilateral bound
constraints is immediate. 

- Kunisch, K., & Rendl, F. (2003). An infeasible active set method for
  quadratic problems with simple bounds. SIAM Journal on Optimization,
  14(1), 35–52. http://dx.doi.org/10.1137/s1052623400376135
  

* Getting started

Once you have imported the package

#+begin_src julia :session *nls_solver_doc* :results output
   using NLS_Solver 
#+end_src

#+RESULTS:

the steps to solve problem are always the same:
- wrap the problem  by sub-typing =AbstractNLS=.
- chose an algorithm
- call the =solve(...)= method
- use the the returned result

In this example we will use the classical Rosenbrock function:

\begin{equation*}
(\theta_1,\theta_2) \mapsto (1-\theta_1)^2 + 100(\theta_2-\theta_1^2)^2
\end{equation*}

which is a nonlinear least squares problem:

\begin{equation*}
\frac{1}{2}\|r(\theta)\|^2\text{ where }r = \sqrt{2} \left( \begin{array}{c}  1-\theta_1 \\ 10(\theta_2-\theta_1^2) \end{array} \right)
\end{equation*}

** Wrap the problem

To wrap the problem we can use a helper function:

#+begin_src julia :session *nls_solver_doc*
  nls = create_NLS_problem_using_ForwardDiff(2 => 2) do θ
    sqrt(2)* [ 1-θ[1], 10*(θ[2]-θ[1]^2) ]
  end
#+end_src

that will compute Jacobian using the [[https://github.com/JuliaDiff/ForwardDiff.jl][ForwardDiff.jl]] package.

- CAVEAT :: do not specify a type, like =Float64=:
  #+begin_src julia :eval never
    nls = create_NLS_problem_using_ForwardDiff(2 => 2) do θ
	sqrt(2)* Float64[ 1-θ[1], 10*(θ[2]-θ[1]^2) ]
    end
  #+end_src
  This would prevent the use of dual numbers to compute the Jacobian.

** Chose an algorithm

Algorithm parameters are defined by sub-typing
=Abstract_Solver_Conf=. This structure is then use to identify the
selected algorithm.  For the moment there is only one implementation,
the classical Levenberg-Marquardt method. To create its default
configuration, proceed as follows:

#+begin_src julia :session *nls_solver_doc* 
conf = Levenberg_Marquardt_Conf()
#+end_src

#+RESULTS:
: Levenberg_Marquardt_Conf(1000, 1.0e-8, 1.0e-8, 0.001)

The methods also need a starting value for the unknown parameter
vector θ:

#+begin_src julia :session *nls_solver_doc* 
θ_init = zeros(2)
#+end_src

#+RESULTS:
: 2-element Vector{Float64}:
:  0.0
:  0.0



There are 4 methods to define:
- parameter_size: :: this is the *θ* parameter vector length, here 2
- residue_size: :: this is the *r* residue vector length, here 2
- eval_r :: this function computes *r* value
- eval_r_J :: this function computes *r* value and its Jacobian matrix wrt to *θ*.

#+begin_src julia :eval never :exports code :noweb-ref jl_def_obj
  struct Rosenbrock <: AbstractNLS
  end

  parameter_size(::Rosenbrock) = 2
  residue_size(::Rosenbrock) = 2

  function eval_r(nls::Rosenbrock,θ::AbstractVector{T}) where T
      @assert length(θ)==parameter_size(nls)

      sqrt(2)* T[ 1-θ[1], 10*(θ[2]-θ[1]^2) ]
  end

  function eval_r_J(nls::Rosenbrock,θ::AbstractVector{T}) where T
      @assert length(θ)==parameter_size(nls)

      r = sqrt(2)* T[ 1-θ[1], 10*(θ[2]-θ[1]^2) ]
      J = sqrt(2)* T[ -1 0; -20*θ[1] 10]

      (r,J)
  end
#+end_src

To solve problems we always call the =solve()= method. For unconstrained
problem, this method has the following prototype

#+begin_src julia  :eval never :exports code
  function solve(nls::AbstractNLS,
		 θ_init::AbstractVector,
		 conf::Abstract_Solver_Conf)::Abstract_Solver_Result
#+end_src

- nls: :: is the problem we just wrapped
- θ_init: :: is the initial value for the unknown parameter vector
- conf: :: is the algorithm we want to use configuration

Let's assume that we want to use the Levenberg-Marquardt method. We
create a default algorithm configuration as follows:
#+begin_src julia :eval never :exports code :noweb-ref jlc_conf
  conf = Levenberg_Marquardt_Conf()
#+end_src
and the initial *θ_init*:
#+begin_src julia :eval never :exports code :noweb-ref jlc_conf
  θ_init = zeros(2)
#+end_src



One must call
the =solve()= method. This method has the following prototype:

