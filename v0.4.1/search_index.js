var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The global API index is as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NLS_Solver]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/#Public","page":"API","title":"Public","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [NLS_Solver]\nPrivate = false\t","category":"page"},{"location":"api/#NLS_Solver.AbstractNLS","page":"API","title":"NLS_Solver.AbstractNLS","text":"abstract type AbstractNLS end \n\nDefines an abstract non-linear least squares problem (NLS). In our context such problem is essentially a differentiable function mathbfr:\n\nmathbfr thetainmathbbR^n_θmapsto mathbfr(mathbftheta)inmathbbR^n_S\n\nwhere:\n\nmathbfr(mathbfθ)mathbbR^n_S is the residue vector,\nmathbfθmathbbR^n_θ is the parameter vector to be optimized\n\nThe objective function to minimize is:\n\nf(θ)=frac12 mathbfr(θ) ^2\n\nThe classical approach uses a linear approximation of mathbfr:\n\nmathbfr(mathbfθ+δmathbfθ)approx mathbfr(mathbfθ) + mathbfJ(mathbfθ)cdot δmathbfθ\n\nwhere mathbfJ is the Jacobian:\n\nmathbfJ_ij=partial_j r^i(mathbfθ) iin1n_S jin1n_θ\n\nThis leads to\n\nf(mathbfθ+δmathbfθ)approx f(mathbfθ) + langle nabla f δmathbfθ rangle + frac12  langle nabla^2 f cdot δmathbfθ  δmathbfθ rangle\n\nWhere the gradient nabla f is mathbfJ^t mathbfr and the (approximate) Hessian nabla^2 f is mathbfJ^t mathbfJ.\n\nTo implement such model, you must define the following functions:\n\nparameter_size : returns n_θ\nresidue_size : returns n_S\neval_r : compute mathbfr\neval_r_J : compute (mathbfr mathbfJ)\n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.Abstract_BC_Solver_Conf","page":"API","title":"NLS_Solver.Abstract_BC_Solver_Conf","text":"abstract type Abstract_BC_Solver_Conf end\n\nAbstract solver configuration. These are the solvers to be used to solve bound constrained nonlinear least squares:\n\nminlimits_theta_l le theta le theta_u  frac12r(theta)^2\n\nImplementations:\n\nLevenbergMarquardt_BC_Conf \n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.Abstract_BC_Solver_Result","page":"API","title":"NLS_Solver.Abstract_BC_Solver_Result","text":"The structure returned by solve when using the LevenbergMarquardt_BC_Conf method.\n\nSee Abstract_Solver_Result \n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.Abstract_Solver_Conf","page":"API","title":"NLS_Solver.Abstract_Solver_Conf","text":"abstract type Abstract_Solver_Conf end\n\nAbstract solver configuration. These are the solvers to be used to solve unconstrained nonlinear least squares:\n\nminlimits_theta frac12r(theta)^2\n\nImplementations:\n\nLevenbergMarquardt_Conf \n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.Abstract_Solver_Result","page":"API","title":"NLS_Solver.Abstract_Solver_Result","text":"abstract type Abstract_Solver_Result end\n\nThis is the base type returned by the solve method. It contains the information related to the founded solution.\n\nInterface\n\nconverged \niteration_count \nobjective_value \nsolution \n\nImplementations\n\nLevenbergMarquardt_Result \nLevenbergMarquardt_BC_Result \n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.BoundConstraints","page":"API","title":"NLS_Solver.BoundConstraints","text":"Store bound constraints lu\n\nPresence of NaN component and the lle u condition is checked at construction time. Note however that some components can be infinite.\n\nConstructors\n\nThe following constructors are available:\n\nConstruct 0010^n \n\nBoundConstraints(n)\n\nConstruct T(0)T(1)^n where components are of type T\n\nBoundConstraints(T,n)\n\nConstruct lu where l and u are lower and upper bound vectors\n\nBoundConstraints(l,u)\n\nRelated functions\n\nBase.eltype(bc::BoundConstraints{ELT}) where ELT \nBase.axes(bc::BoundConstraints) \nBase.length(bc::BoundConstraints) \nBase.size(bc::BoundConstraints) \nin(x::AbstractArray{<:Real,N},bc::BoundConstraints{<:Real,N}) where N \nlower_bound(bc::BoundConstraints) \nupper_bound(bc::BoundConstraints) \nproject!(x::AbstractArray{<:Real,N},bc::BoundConstraints{<:Real,N}) where N \nBase.:-(bc::BoundConstraints,τ::AbstractArray) \nBase.:+(bc::BoundConstraints,τ::AbstractArray) \n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.LevenbergMarquardt_BC_Conf","page":"API","title":"NLS_Solver.LevenbergMarquardt_BC_Conf","text":"mutable struct LevenbergMarquardt_BC_Conf <: Abstract_Solver_Conf\n    ...\nend\n\nUse this constructor\n\nLevenbergMarquardt_BC_Conf()\n\nto initialize the bound constrained Levenberg-Marquardt solver default configuration parameters.\n\nTo solve a problem with this method, you must then call  solve(nls::AbstractNLS, θ_init::AbstractVector, bc::BoundConstraints, conf::Abstract_BC_Solver_Conf) \n\nSee: \n\nset_max_iteration!(conf::LevenbergMarquardt_BC_Conf,max_iter::Int) \nset_ε_grad_Inf_norm!(conf::LevenbergMarquardt_BC_Conf,ε_grad_Inf_norm::Float64) \nset_ε_step_Inf_norm!(conf::LevenbergMarquardt_BC_Conf,ε_step_Inf_norm::Float64) \n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.LevenbergMarquardt_BC_Result","page":"API","title":"NLS_Solver.LevenbergMarquardt_BC_Result","text":"struct LevenbergMarquardt_BC_Result{T<:Real} <:  Abstract_BC_Solver_Result\n    ...\nend \n\nThis structure subtypes Abstract_BC_Solver_Result\n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.LevenbergMarquardt_Conf","page":"API","title":"NLS_Solver.LevenbergMarquardt_Conf","text":"mutable struct LevenbergMarquardt_Conf <: Abstract_Solver_Conf\n    ...\nend\n\nUse this constructor\n\nLevenbergMarquardt_Conf()\n\nto initialize the Levenberg-Marquardt solver default configuration parameters.\n\nTo solve a problem with this method, you must then call  solve(nls::AbstractNLS, θ_init::AbstractVector, conf::Abstract_Solver_Conf) \n\nSee: \n\nset_max_iteration!(conf::LevenbergMarquardt_Conf,max_iter::Int) \nset_ε_grad_Inf_norm!(conf::LevenbergMarquardt_Conf,ε_grad_Inf_norm::Float64) \nset_ε_step_Inf_norm!(conf::LevenbergMarquardt_Conf,ε_step_Inf_norm::Float64) \n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.LevenbergMarquardt_Result","page":"API","title":"NLS_Solver.LevenbergMarquardt_Result","text":"struct LevenbergMarquardt_Result{T<:Real} <: Abstract_Solver_Result\n   ...\nend\n\nThis structure subtypes Abstract_Solver_Result\n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.NLS_ForwardDiff","page":"API","title":"NLS_Solver.NLS_ForwardDiff","text":"struct NLS_ForwardDiff <: AbstractNLS\n    ...\nend\n\n\nA specialization that uses the ForwardDiff package to compute the Jacobian.\n\nBy comparison with AbstractNLS you only have to define these functions:\n\nparameter_size : returns n_θ\nresidue_size : returns n_S\neval_r : computation of mathbfr\n\nSee: create_NLS_problem_using_ForwardDiff \n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.converged-Tuple{Abstract_Solver_Result}","page":"API","title":"NLS_Solver.converged","text":"converged(::Abstract_Solver_Result)\n\nReturn true if the solver converged\n\nSee: Abstract_Solver_Result \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.converged-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}","page":"API","title":"NLS_Solver.converged","text":"converged(::Abstract_BC_QuadSolver_Result)\n\nReturn true if the solver converged\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.create_NLS_problem_using_ForwardDiff-Tuple{Function, Pair{Int64, Int64}}","page":"API","title":"NLS_Solver.create_NLS_problem_using_ForwardDiff","text":"create_NLS_problem_using_ForwardDiff(r::Function;domain_image_dim::Pair{Int,Int})\n\nCreates an AbstractNLS specialized instance where the eval_r_J function is automatically defined using automatic differentiation.\n\nr is a function that maps a parameter vector θ to its residue. The Jacobian matrix is computed using the ForwardDiff package.\ndomain_image_dim is a pair of the form θ length => r length that defines domain and codomain dimensions.\n\nUsage example\n\nAn example defining the Rosenbrock function\n\nfrac12r(theta)^2text where r = sqrt2 left( beginarrayc  1-theta_1  10(theta_2-theta_1^2) endarray right)\n\nnls = create_NLS_problem_using_ForwardDiff(2 => 2) do θ\n     sqrt(2) sqrt(2)* [ 1-θ[1], 10*(θ[2]-θ[1]^2) ]* [ 1-θ[1], 10*(θ[2]-θ[1]^2) ]\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.eval_nls_fobj-Tuple{AbstractVector{T} where T}","page":"API","title":"NLS_Solver.eval_nls_fobj","text":"eval_nls_fobj(r::AbstractVector{T}) -> f(θ)\n\nCompute f(θ)=frac12 mathbfr(mathbfθ) ^2\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.eval_nls_∇fobj-Tuple{AbstractVector{T} where T, AbstractMatrix{T} where T}","page":"API","title":"NLS_Solver.eval_nls_∇fobj","text":"eval_nls_∇fobj(r,J) -> ∇fobj\n\nCompute the gradient: nabla f(mathbfθ) = mathbfJ^tmathbfr\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.eval_nls_∇∇fobj-Tuple{AbstractMatrix{T} where T}","page":"API","title":"NLS_Solver.eval_nls_∇∇fobj","text":"eval_nls_∇∇fobj(J) -> ∇∇fobj\n\nCompute the (approximate) Hessian: nabla^2 f(mathbfθ) = mathbfJ^tmathbfJ\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.eval_r-Tuple{AbstractNLS, AbstractVector{T} where T}","page":"API","title":"NLS_Solver.eval_r","text":"eval_r(nls::AbstractNLS,\n        θ::AbstractVector) -> r\n\nCompte the residual vector mathbfr\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.eval_r_J-Tuple{AbstractNLS, AbstractVector{T} where T}","page":"API","title":"NLS_Solver.eval_r_J","text":"eval_r_J(nls::AbstractNLS,θ::AbstractVector) -> (r,J)\n\nCompute the residual the vector mathbfr and its Jacobian mathbfJ \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.iteration_count-Tuple{Abstract_Solver_Result}","page":"API","title":"NLS_Solver.iteration_count","text":"iteration_count(::Abstract_Solver_Result)\n\nReturn the number of consumed iteration\n\nSee: Abstract_Solver_Result \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.iteration_count-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}","page":"API","title":"NLS_Solver.iteration_count","text":"iteration_count(::Abstract_BC_QuadSolver_Result)\n\nReturn the number of consumed iteration\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.lower_bound-Tuple{BoundConstraints}","page":"API","title":"NLS_Solver.lower_bound","text":"lower_bound(bc::BoundConstraints)\n\nReturn lower bound l\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.objective_value-Tuple{Abstract_Solver_Result}","page":"API","title":"NLS_Solver.objective_value","text":"objective_value(::Abstract_Solver_Result)\n\nReturns objective value at the point solution.\n\nSee: Abstract_Solver_Result \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.objective_value-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}","page":"API","title":"NLS_Solver.objective_value","text":"objective_value(::Abstract_BC_QuadSolver_Result)\n\nReturns objective value at the point solution.\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.parameter_size-Tuple{AbstractNLS}","page":"API","title":"NLS_Solver.parameter_size","text":"parameter_size(nls::AbstractNLS)\n\nReturn the dimension n_θ of the parameter vector θ.\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.project!-Union{Tuple{N}, Tuple{AbstractArray{var\"#s1\", N} where var\"#s1\"<:Real, BoundConstraints{var\"#s9\", N, LBT, UBT} where {var\"#s9\"<:Real, LBT<:AbstractArray{var\"#s9\", N}, UBT<:AbstractArray{var\"#s9\", N}}}} where N","page":"API","title":"NLS_Solver.project!","text":"project!(x::AbstractArray{<:Real,N},bc::BoundConstraints{<:Real,N})\n\nProject x such that x in lu is fullfiled.\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.residue_size-Tuple{AbstractNLS}","page":"API","title":"NLS_Solver.residue_size","text":"sample_size(nls::AbstractNLS)\n\nReturn the dimension n_S of the residue vector r.\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_BC_Conf, Int64}","page":"API","title":"NLS_Solver.set_max_iteration!","text":"set_max_iteration!(conf::LevenbergMarquardt_BC_Conf,\n                   max_iter::Int)\n\nModify the maximum number of iterations\n\nSee: LevenbergMarquardt_BC_Conf \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.set_max_iteration!-Tuple{LevenbergMarquardt_Conf, Int64}","page":"API","title":"NLS_Solver.set_max_iteration!","text":"set_max_iteration!(conf::LevenbergMarquardt_Conf,\n                   max_iter::Int)\n\nModify the maximum number of iterations\n\nSee: LevenbergMarquardt_Conf \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}","page":"API","title":"NLS_Solver.set_ε_grad_Inf_norm!","text":"set_ε_grad_Inf_norm!(conf::LevenbergMarquardt_BC_Conf,\n                     ε_grad_Inf_norm::Float64)\n\nModify the stopping criterion nabla f_inftyleepsilon\n\nSee: LevenbergMarquardt_BC_Conf \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.set_ε_grad_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}","page":"API","title":"NLS_Solver.set_ε_grad_Inf_norm!","text":"set_ε_grad_Inf_norm!(conf::LevenbergMarquardt_Conf,\n                     ε_grad_Inf_norm::Float64)\n\nModify the stopping criterion nabla f_inftyleepsilon\n\nSee: LevenbergMarquardt_Conf \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_BC_Conf, Float64}","page":"API","title":"NLS_Solver.set_ε_step_Inf_norm!","text":"set_ε_step_Inf_norm!(conf::LevenbergMarquardt_BC_Conf,\n                     ε_step_Inf_norm::Float64)\n\nModify the stopping criterion delta x_inftyleepsilon\n\nSee: LevenbergMarquardt_BC_Conf \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.set_ε_step_Inf_norm!-Tuple{LevenbergMarquardt_Conf, Float64}","page":"API","title":"NLS_Solver.set_ε_step_Inf_norm!","text":"set_ε_step_Inf_norm!(conf::LevenbergMarquardt_Conf,\n                     ε_step_Inf_norm::Float64)\n\nModify the stopping criterion delta x_inftyleepsilon\n\nSee: LevenbergMarquardt_Conf \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.solution-Tuple{Abstract_Solver_Result}","page":"API","title":"NLS_Solver.solution","text":"solution(::Abstract_Solver_Result)\n\nReturns the founded solution \n\nSee: Abstract_Solver_Result \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.solution-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}","page":"API","title":"NLS_Solver.solution","text":"solution(::Abstract_BC_QuadSolver_Result)\n\nReturns the founded solution \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, Abstract_Solver_Conf}","page":"API","title":"NLS_Solver.solve","text":"solve(nls::AbstractNLS,\n      θ_init::AbstractVector,\n      conf::Abstract_Solver_Conf)::Abstract_Solver_Result\n\nGeneric interface to solve an AbstractNLS problem.\n\nThe used algorithm is defined through Abstract_Solver_Conf specializations.\n\nThe method returns a Abstract_Solver_Result specialization.\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.solve-Tuple{AbstractNLS, AbstractVector{T} where T, BoundConstraints, Abstract_BC_Solver_Conf}","page":"API","title":"NLS_Solver.solve","text":"solve(nls::AbstractNLS,\n      θ_init::AbstractVector,\n      bc::BoundConstraints,\n      conf::Abstract_BC_Solver_Conf) -> Abstract_Solver_Result\n\nGeneric interface to solve a AbstractNLS problem with bound constraints.\n\nThe used algorithm is defined through Abstract_BC_Solver_Conf specializations.\n\nThe method returns a Abstract_BC_Solver_Result specialization.\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.upper_bound-Tuple{BoundConstraints}","page":"API","title":"NLS_Solver.upper_bound","text":"upper_bound(bc::BoundConstraints)\n\nReturn upper bound u\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#Private","page":"API","title":"Private","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [NLS_Solver]\nPublic = false\t","category":"page"},{"location":"api/#NLS_Solver.Abstract_BC_QuadSolver_Result","page":"API","title":"NLS_Solver.Abstract_BC_QuadSolver_Result","text":"abstract type Abstract_BC_QuadSolver_Result end\n\nQuadratic solver result abstraction\n\n\n\n\n\n","category":"type"},{"location":"api/#NLS_Solver.BoundConstraint_Enum","page":"API","title":"NLS_Solver.BoundConstraint_Enum","text":"@enum(BoundConstraint_Enum,\n      ACTIVE_LB = -1,\n      INACTIVE_BC = 0,\n      ACTIVE_UB = +1)\n\nAn enum to store bound constraint state.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:+-Tuple{BoundConstraints, AbstractArray}","page":"API","title":"Base.:+","text":"Base.:+(bc::BoundConstraints,τ::AbstractArray)\n\nTranslate bound constraints\n\na+τb+τ = ab+τ\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Tuple{BoundConstraints, AbstractArray}","page":"API","title":"Base.:-","text":"Base.:-(bc::BoundConstraints,τ::AbstractArray)\n\nTranslate bound constraints\n\na-τb-τ = ab-τ\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.axes-Tuple{BoundConstraints}","page":"API","title":"Base.axes","text":"axes(bc::BoundConstraints)\n\nReturn bound axes\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.eltype-Union{Tuple{BoundConstraints{ELT, N, LBT, UBT} where {N, LBT<:AbstractArray{ELT, N}, UBT<:AbstractArray{ELT, N}}}, Tuple{ELT}} where ELT","page":"API","title":"Base.eltype","text":"eltype(bc::BoundConstraints)\n\nReturn bound element type\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.in-Union{Tuple{N}, Tuple{AbstractArray{var\"#s6\", N} where var\"#s6\"<:Real, BoundConstraints{var\"#s7\", N, LBT, UBT} where {var\"#s7\"<:Real, LBT<:AbstractArray{var\"#s7\", N}, UBT<:AbstractArray{var\"#s7\", N}}}} where N","page":"API","title":"Base.in","text":"in(bc::BoundConstraints)\n\nCheck if xin lu\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{BoundConstraints}","page":"API","title":"Base.length","text":"length(bc::BoundConstraints)\n\nReturn bound length\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{BoundConstraints}","page":"API","title":"Base.size","text":"size(bc::BoundConstraints)\n\nReturn bound size\n\nSee: BoundConstraints \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.check_first_order-Tuple{AbstractVector{var\"#s5\"} where var\"#s5\"<:Real, AbstractVector{var\"#s3\"} where var\"#s3\"<:Real, BoundConstraints{var\"#s2\", 1, LBT, UBT} where {var\"#s2\"<:Real, LBT<:AbstractVector{var\"#s2\"}, UBT<:AbstractVector{var\"#s2\"}}}","page":"API","title":"NLS_Solver.check_first_order","text":"check_first_order(∇f::AbstractVector{<:Real},\n                  xstar::AbstractVector{<:Real},\n                  bc::BoundConstraints{<:Real,1})\n\ncheck_first_order(Q::Symmetric{<:Real},\n                  q::AbstractVector{<:Real},\n                  xstar::AbstractVector{<:Real},\n                  bc::BoundConstraints{<:Real,1})\n\nCheck First-Order Conditions  (see Bound Constrained Optimization slides)\n\nIf x^star=argmin f(x) xinlu then:\n\npartial_i f(x^star) = leftbeginarrayll\nge 0  textif  x^stari = li \n= 0  textif  li le x^stari le ui \nle 0  textif  x^stari = ui \nendarray\nright\n\nThis is equivalent to:\n\nx^star = P_lu(x^star-nabla f(x^star))\n\nAccording to the previous result, this function returns:\n\nmax mid x^star - P_lu(x^star-(Qx^star+q)) mid\n\nFor a local stationary point this quantity must be null \n\nThe second function is a wrapper that computes f=Qx^star+q\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.clean_τ!-Tuple{AbstractArray{var\"#s9\", N} where {var\"#s9\"<:Real, N}, AbstractArray{NLS_Solver.BoundConstraint_Enum, N} where N}","page":"API","title":"NLS_Solver.clean_τ!","text":"clean_τ!(τ::AbstractArray{<:Real},              \n         Z::AbstractArray{BoundConstraint_Enum})\n\nBy definition τ=-Qx-q. If the algorithm converged, then one must have τ[i]=0 when the constraint is inactive.\n\nThis function updates τ by overwriting τ[i]=0 when Z[i]=inactive. \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.compute_δL_constrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T, AbstractVector{T} where T}","page":"API","title":"NLS_Solver.compute_δL_constrained","text":"Same idea than compute_δL_unconstrained, however when bound constraints are present h is such that:\n\n(nabla^2 f + mu I)h + nabla f + tau = 0\n\nit follows that:\n\nδL = L(0)-L(h) = frac12 langle h mu h + tau - nabla f rangle\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.compute_δL_unconstrained-Tuple{AbstractVector{T} where T, Real, AbstractVector{T} where T}","page":"API","title":"NLS_Solver.compute_δL_unconstrained","text":"Compute δL = L(0)-L(h) where L is the quadratic model\n\nL(h)=f(theta) + langle nabla f h rangle + frac12langle nabla^2 f h h rangle\n\nwith f(theta)=frac12 r(θ) _2^2, nabla f = J^t r and nabla^2 f = J^t J\n\nA direct computation gives:\n\nδL = L(0)-L(h) = -left(  langle J^tr h rangle + frac12langle nabla^2 f h h rangle right)\n\nHowever one can avoid the computation of nabla^2 f h if one uses the fact that h is solution of:\n\n(nabla^2 f + mu I)h + nabla f = 0\n\nWith this hypothesis, one gets:\n\nδL = L(0)-L(h) = frac12 langle h mu h - nabla f rangle\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.compute_δf-Tuple{AbstractVector{T} where T, AbstractVector{T} where T}","page":"API","title":"NLS_Solver.compute_δf","text":"Compute true variation of the real model: δf = frac12(r^t(θ)r(θ)-r^t(θ+h)r(θ+h))\n\nContrary to δL things are simpler. However a trick is to use an equivalent formulation:\n\nδf = frac12(r^t(θ)r(θ)-r^t(θ+h)r(θ+h)) = frac12(r(θ)-r(θ+h))^t(r(θ)+r(θ+h))\n\nthat has a better numerical behavior. \n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.initialize_x_Z-Tuple{AbstractArray, BoundConstraints}","page":"API","title":"NLS_Solver.initialize_x_Z","text":"initialize_x_Z(x_init::AbstractArray,\n               bc::BoundConstraints)\n\nCreate (x,Z) from initial guess x_init and bound constraints bc\n\nZ is created by recording how x_init fulfils the bound constraints bc.\n\nx is the projection of x_init on the bounded domain [l,b].\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.multiplier_τ-Tuple{NLS_Solver.Abstract_BC_QuadSolver_Result}","page":"API","title":"NLS_Solver.multiplier_τ","text":"multiplier_τ(::Abstract_BC_QuadSolver_Result)\n\nReturns the multipliers stored in a compact form (see τ definition, TODO)\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.quadratic_subproblem-Tuple{LinearAlgebra.Symmetric{var\"#s6\", S} where {var\"#s6\"<:Real, S<:(AbstractMatrix{var\"#s814\"} where var\"#s814\"<:var\"#s6\")}, AbstractVector{var\"#s5\"} where var\"#s5\"<:Real, AbstractVector{var\"#s3\"} where var\"#s3\"<:Real, BoundConstraints{var\"#s2\", 1, LBT, UBT} where {var\"#s2\"<:Real, LBT<:AbstractVector{var\"#s2\"}, UBT<:AbstractVector{var\"#s2\"}}, NLS_Solver.Abstract_BC_QuadSolver_Conf, NLS_Solver.LM_Damping, Int64}","page":"API","title":"NLS_Solver.quadratic_subproblem","text":"Solve\n\nminlimits_hθ^l-θθ^u-θfrac12h^t(H+μI)h + f^th\n\nWe use the quadratic model of f, the bound contraints are such that the step h makes the update x+h falls in the θ^lθ^u bound.\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.restrict_to_inactive!-Tuple{LinearAlgebra.Symmetric, AbstractVector{T} where T, AbstractVector{NLS_Solver.BoundConstraint_Enum}, AbstractVector{var\"#s3\"} where var\"#s3\"<:Real, AbstractVector{var\"#s2\"} where var\"#s2\"<:Real}","page":"API","title":"NLS_Solver.restrict_to_inactive!","text":"restrict_to_inactive!(Q::Symmetric,\n                      q::AbstractVector,\n                      Z::AbstractVector{BoundConstraint_Enum},\n                      lb::AbstractVector{<:Real},\n                      ub::AbstractVector{<:Real})\n\nfunction restrict_to_inactive!(Q::Symmetric,\n                               q::AbstractVector,\n                               Z::AbstractVector{BoundConstraint_Enum},\n                               bc::BoundConstraints{<:Real,1})\n\nIn-place modification of (Qq) that produces (tildeQtildeq) such that the initial optimization problem:\n\ntildex = argmin frac12 x^t Q x + q^tx\n\nunder these constraints:\n\nxi = leftbeginarrayll \nli  textif  Zi = -1 \nui  textif  Zi = +1 \nendarrayright\n\nis transformed into this linear system:\n\ntildeQtildex+tildeq=0\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.update_Z!-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, AbstractVector{NLS_Solver.BoundConstraint_Enum}, AbstractVector{T} where T, AbstractVector{T} where T}","page":"API","title":"NLS_Solver.update_Z!","text":"update_Z!(x::AbstractVector,\n          τ::AbstractVector,\n          Z::AbstractVector{BoundConstraint_Enum},\n          lb::AbstractVector,\n          ub::AbstractVector)\n\nupdate_Z!(x::AbstractVector,\n          τ::AbstractVector,\n          Z::AbstractVector{BoundConstraint_Enum},\n          bc::BoundConstraints{<:Real,1})\n\nThis function updates Z according to x, τ and bounds lb, ub values.\n\nIt also count how many changes have be done during this update.\n\nNo change means that the algorithm has converged.\n\nNote: this function only modifies Z and return the number of bad hypothesis.\n\n\n\n\n\n","category":"method"},{"location":"api/#NLS_Solver.update_x!-Tuple{AbstractArray, AbstractArray{NLS_Solver.BoundConstraint_Enum, N} where N, BoundConstraints}","page":"API","title":"NLS_Solver.update_x!","text":"update_x!(x::AbstractArray,\n          Z::AbstractArray{BoundConstraint_Enum},\n          bc::BoundConstraints)\n\nUpdate x value such that:\n\nxi = leftbeginarrayll \nli  textif  Zi = -1 \nui  textif  Zi = +1 \nendarrayright\n\nWhen Zi=0 the xi value is unaffected.\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"CurrentModule = NLS_Solver","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"using NLS_Solver\nusing Random\nusing Plots\nENV[\"GKSwstype\"]=100\ngr()","category":"page"},{"location":"nonlinear_regressions/#Nonlinear-regressions","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"","category":"section"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"This NLS_Solver.jl package is a generic nonlinear least squares solver. However a very common use of this kind of solver is nonlinear regression. In this tutorial we show how this package can be used in this context. You can reproduce the computation thanks to sandbox/nonlinear_regression.jl.","category":"page"},{"location":"nonlinear_regressions/#Synthetic-data","page":"Nonlinear regressions","title":"Synthetic data","text":"","category":"section"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"We will fit an exponential baseline plus a gaussian peak of the form:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"h expleft(-frac12left(fracx-musigmaright)^2right) + b expleft(-fracxtauright)","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"We first define some bricks for our model","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"function gaussian_peak(x::Real,\n                       h::Real,\n                       μ::Real,\n                       σ::Real)\n    @assert σ>0\n    \n    h*exp(-((x-μ)/σ)^2/2)\nend\n\nfunction exp_baseline(x::Real,\n                      b::Real,\n                      τ::Real)\n    @assert τ>0\n\n    b*exp(-x/τ)\nend\n          \nfunction model(x::Real,θ::AbstractVector)\n    @assert length(θ) == 5\n    \n    # one gaussian peaks + exp baseline\n    #\n    (h, μ, σ, b, τ) = (θ_i for θ_i in θ)\n    \n    gaussian_peak(x,h,μ,σ) + exp_baseline(x,b,τ) \nend\n\nnothing # hide","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"Now the important function that computes the residue:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"r_i(θ) = Y_i - m(X_iθ) i=1dotsn_textsample","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"where the r_i components are used to define the objective function frac12r(θ)_2^2.","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"function residue(X::AbstractVector,Y::AbstractVector,θ::AbstractVector)\n    map(zip(X,Y)) do (X_i,Y_i)\n        Y_i - model(X_i, θ)\n    end\nend\n\nnothing # hide","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"We are now ready to generate our synthetic data:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"X=[1:0.1:30;]\nθ_true=[2.0,15,3.0,3.0,8.0]\n\nY_true  = map(X_i -> model(X_i,θ_true), X)\nY_noisy = map(Y_i -> Y_i + 0.5 * randn(), Y_true)\n\nplot(X,Y_noisy,label=\"noisy signal\")\nplot!(X,Y_true,linewidth=3,linestyle=:dot,label=\"true signal\")","category":"page"},{"location":"nonlinear_regressions/#Solve-the-problem","page":"Nonlinear regressions","title":"Solve the problem","text":"","category":"section"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"Now we solve the problem in as we have done for Bound constrained nonlinear least squares.","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"The problem dimensions are:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"n_θ = length(θ_true)\nn_sample = length(X)\nnothing # hide","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"We impose some bound constraints:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"#                         h,  μ,  σ,   b,  τ\nθ_lowerbound = Float64[   1, 10,  1,   0,  1 ]\nθ_upperbound = Float64[ Inf, 20, 10, Inf, 10 ]\nbc = BoundConstraints(θ_lowerbound, θ_upperbound)\nnothing # hide","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"The initial guess is the  vector mathbf1. ","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"θ_init = ones(n_θ)\nnothing # hide ","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"note: Note\nYou can call the solve() function with an unfeasible initial vector θ.  (where ==unfeasible== means that the bound constraints are not fulfilled). ","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"Then we choose the solver (only one choice for the moment):","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"conf = LevenbergMarquardt_BC_Conf()\nnothing # hide ","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"We define the nonlinear least squares problem from the residue() function:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"nls = create_NLS_problem_using_ForwardDiff(θ->residue(X,Y_noisy,θ),n_θ => n_sample)\nnothing # hide ","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"The residue Jacobian is computed using automatic differentiation.","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"We can now solve the problem:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"result = solve(nls,θ_init,bc,conf)\nnothing # hide","category":"page"},{"location":"nonlinear_regressions/#Fit-result","page":"Nonlinear regressions","title":"Fit result","text":"","category":"section"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"We check that the solver converged:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"@assert converged(result)","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"θ_solution = solution(result)","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"and plot the fitted model:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"Y_solution = map(X_i -> model(X_i,θ_solution), X)\nplot!(X,Y_solution,linewidth=3,label=\"fitted model\")","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"We can get furthers information from the result structure:","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"iteration_count(result)","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"objective_value(result)","category":"page"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"note: Note\nIn the future I will add gradient, Hessian and multipliers at the solution.  However, please note that in the constrained case you cannot use (J^tJ)^-1 directly to estimate your parameter uncertainties.","category":"page"},{"location":"nonlinear_regressions/#More-fit-examples","page":"Nonlinear regressions","title":"More fit examples","text":"","category":"section"},{"location":"nonlinear_regressions/","page":"Nonlinear regressions","title":"Nonlinear regressions","text":"This NLS_Solver.jl package is used by the NLS_Fit.jl package which is dedicated to peak fitting in spectrometry. You will find there other examples of model fitting.","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"CurrentModule = NLS_Solver","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"using NLS_Solver","category":"page"},{"location":"bound_constrained_nls/#bc_nls_pb","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"","category":"section"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"In this part we see how to solve problems of the form:","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"beginalign*\nminlimits_theta  frac12r(theta)^2 \n                      theta_llethetaletheta_u\nendalign*","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"Compared to the unconstrained case, there are essentially two differences: ","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"the solve() function has an extra parameter, bc that store bound constraints.\nThe solver category is different and Abstract_Solver_Conf, it replaced by Abstract_BC_Solver_Conf, where BC stands for bound constrained.","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"Furthers details can be found there: solve(nls::AbstractNLS, θ_init::AbstractVector, bc::BoundConstraints, conf::Abstract_BC_Solver_Conf)","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"You can reproduce the results below using sandbox/example_Rosenbrock.jl","category":"page"},{"location":"bound_constrained_nls/#Problem-definition","page":"Bound constrained nonlinear least squares","title":"Problem definition","text":"","category":"section"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"Identical to the unconstrained case. We have:","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"nls = create_NLS_problem_using_ForwardDiff(2 => 2) do θ\n  sqrt(2)* [ 1-θ[1], 10*(θ[2]-θ[1]^2) ]\nend\nnothing # hide","category":"page"},{"location":"bound_constrained_nls/#Choose-a-solver","page":"Bound constrained nonlinear least squares","title":"Choose a solver","text":"","category":"section"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"Algorithm parameters are defined by sub-typing Abstract_BC_Solver_Conf. This structure is then used to identify the selected algorithm. For the moment there is only one implementation, the a bound constrained version of the classical Levenberg-Marquardt method:","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"conf = LevenbergMarquardt_BC_Conf()","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"We also need a starting point for the theta. Here we start at point (33):","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"θ_init = Float64[3,3]","category":"page"},{"location":"bound_constrained_nls/#The-solve()-function","page":"Bound constrained nonlinear least squares","title":"The solve() function","text":"","category":"section"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"To solve the problem you simply have to call the solve() function. For bound constrained problems, this function has the following prototype","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"function solve(nls::AbstractNLS,\n               θ_init::AbstractVector,\n               bc::BoundConstraints,\n               conf::Abstract_Solver_Conf)::Abstract_Solver_Result","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"In our case, if we want 2 le theta_i le 4 this gives","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"θl = Float64[2,2]\nθu = Float64[4,4]\n\nbc = BoundConstraints(θl,θu)\n\nresult = solve(nls, θ_init, bc, conf)","category":"page"},{"location":"bound_constrained_nls/#Using-solver-result","page":"Bound constrained nonlinear least squares","title":"Using solver result","text":"","category":"section"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"The solve() function returns a Abstract_BC_Solver_Result sub-typed structure that contains algorithm result.","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"In peculiar you can check if the method has converged","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"@assert converged(result)","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"and get the optimal θ","category":"page"},{"location":"bound_constrained_nls/","page":"Bound constrained nonlinear least squares","title":"Bound constrained nonlinear least squares","text":"θ_solution = solution(result)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = NLS_Solver","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using NLS_Solver","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"NLS_Solver.jl is a pure Julia package to solve unconstrained and bound constrained nonlinear least squares problems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"classical nonlinear least squares:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"minlimits_theta frac12r(theta)^2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"bound constrained nonlinear least squares","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"minlimits_theta_llethetaletheta_u frac12r(theta)^2","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is easy to use. Problems are solved by calling a generic solve() function of the form:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"solve(problem, algorithm_conf)::algorithm_result","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"problem is problem dependant data\nalgorithm_conf defines the chosen algorithm\nalgorithm_result is a structure that contains the result.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Detailed examples are provided belows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"unconstrained_nls.md\",\n    \"bound_constrained_nls.md\",\n    \"nonlinear_regressions.md\",\n]\nDepth = 3","category":"page"},{"location":"#Detailed-documentation","page":"Introduction","title":"Detailed documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"api.md\",\n]\nDepth = 3","category":"page"},{"location":"#Algorithms-and-references","page":"Introduction","title":"Algorithms and references","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For the moment two methods are implemented. The classical Levenberg-Marquardt method for unconstrained problems and a modified Levenberg-Marquardt method for bound constrained problems.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"These implementations are mainly based on these references:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Madsen, N. (). Methods For Non-Linear Least Squares Problems. imm3215.pdf \nThis reference is a must read about nonlinear least squares algorithms.\nNielsen, H. B., & others, (1999). Damping parameter in marquardt's method. tr05_99.pdf\nThis second reference provides some details about damping parameter. It also gives an useful list of test functions (unconstrained case).\nKunisch, K., & Rendl, F. (2003). An infeasible active set method for quadratic problems with simple bounds. SIAM Journal on Optimization, 14(1), 35–52. epubs.siam.org\nThis reference presents an efficient method to solve bound constrained quadratic problems.","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"CurrentModule = NLS_Solver","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"using NLS_Solver","category":"page"},{"location":"unconstrained_nls/#Unconstrained-nonlinear-least-squares","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"","category":"section"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"In this part we see how to solve problems of the form:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"minlimits_theta frac12r(theta)^2","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"For that we have to call the solve(nls::AbstractNLS, θ_init::AbstractVector, conf::Abstract_Solver_Conf).","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"One must define:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"an AbstractNLS instance, this is the object of the Problem definition section\nan Abstract_Solver_Conf instance, this is the object of the Choose a solver section","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"You can reproduce the results below using sandbox/example_Rosenbrock.jl","category":"page"},{"location":"unconstrained_nls/#rosenbrock_nls","page":"Unconstrained nonlinear least squares","title":"Problem definition","text":"","category":"section"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"For this example we will use the classical Rosenbrock function:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"(theta_1theta_2) mapsto (1-theta_1)^2 + 100(theta_2-theta_1^2)^2","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"which can be viewed as a nonlinear least squares problem, with:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"frac12r(theta)^2text where r = sqrt2 left( beginarrayc  1-theta_1  10(theta_2-theta_1^2) endarray right)","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"The first task is to wrap the problem. The easiest way is to let the ForwardDiff.jl package computes the Jacobian. In that case you only have to provide the objective function. For that call the create_NLS_problem_using_ForwardDiff :","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"nls = create_NLS_problem_using_ForwardDiff(2 => 2) do θ\n  sqrt(2)* [ 1-θ[1], 10*(θ[2]-θ[1]^2) ]\nend\nnothing # hide","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"The returned nls is an instance of AbstractNLS. ","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"danger: Danger\nDo not specify a type, like Float64nls = create_NLS_problem_using_ForwardDiff(2 => 2) do θ\n    sqrt(2)* Float64[ 1-θ[1], 10*(θ[2]-θ[1]^2) ]\nendThis would prevent the use of dual numbers to compute the Jacobian.","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"note: Note\nAn alternative, if you do not want to use the do...end syntax, would be:Rosenbrock(θ::AbstractVector{T}) where T = sqrt(2)* T[ 1-θ[1], 10*(θ[2]-θ[1]^2) ]\n\nnls = create_NLS_problem_using_ForwardDiff(Rosenbrock,2 => 2);","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"note: Note\nIf you do not want to use create_NLS_problem_using_ForwardDiff you can directly sub-type AbstractNLS by defining all the required method. This is described in direct sub-typing of AbstractNLS","category":"page"},{"location":"unconstrained_nls/#lm_solver_cong","page":"Unconstrained nonlinear least squares","title":"Choose a solver","text":"","category":"section"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"Algorithm parameters are defined by sub-typing Abstract_Solver_Conf. This structure is then used to identify the selected algorithm. For the moment there is only one implementation, the classical Levenberg-Marquardt method:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"conf = LevenbergMarquardt_Conf()","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"We also need a starting point for the theta parameter vector. We can create a zero filled vector:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"θ_init = zeros(parameter_size(nls))","category":"page"},{"location":"unconstrained_nls/#The-solve()-function","page":"Unconstrained nonlinear least squares","title":"The solve() function","text":"","category":"section"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"To solve the problem you simply have to call the solve() function. For unconstrained problems, this function has the following prototype","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"function solve(nls::AbstractNLS,\n               θ_init::AbstractVector,\n               conf::Abstract_Solver_Conf)::Abstract_Solver_Result","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"In our case this gives","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"result = solve(nls, θ_init, conf)","category":"page"},{"location":"unconstrained_nls/#Using-solver-result","page":"Unconstrained nonlinear least squares","title":"Using solver result","text":"","category":"section"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"The solve() function returns a Abstract_Solver_Result sub-typed structure that contains algorithm result.","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"In peculiar you can check if the method has converged","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"@assert converged(result)","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"and get the optimal θ","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"θ_solution = solution(result)","category":"page"},{"location":"unconstrained_nls/#nls_subtyping","page":"Unconstrained nonlinear least squares","title":"Annex: direct sub-typing of AbstractNLS","text":"","category":"section"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"To wrap the objective function, you can sub-type AbstractNLS. In that case, you have to define everything, including the function that computes the Jacobian.","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"More precisely, you have to define 4 methods:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"parameter_size : returns the θ parameter vector length\nresidue_size : returns the r residue vector length\neval_r : computes the residue r value\neval_r_J : computes the residue r value and its Jacobian matrix wrt to theta.","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"For the Rosenbrock function this gives:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"struct Rosenbrock <: NLS_Solver.AbstractNLS\nend\n\nimport NLS_Solver: parameter_size, residue_size, eval_r, eval_r_J\n\nNLS_Solver.parameter_size(::Rosenbrock) = 2\nNLS_Solver.residue_size(::Rosenbrock) = 2\n\nfunction NLS_Solver.eval_r(nls::Rosenbrock,θ::AbstractVector{T}) where T\n    @assert length(θ)==parameter_size(nls)\n\n    sqrt(2)* T[ 1-θ[1], 10*(θ[2]-θ[1]^2) ]\nend\n\nfunction NLS_Solver.eval_r_J(nls::Rosenbrock,θ::AbstractVector{T}) where T\n    @assert length(θ)==parameter_size(nls)\n\n    r = sqrt(2)* T[ 1-θ[1], 10*(θ[2]-θ[1]^2) ]\n    J = sqrt(2)* T[ -1 0; -20*θ[1] 10]\n\n    (r,J)\nend\n\nnothing # hide","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"All the remaining parts are identical:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"nls = Rosenbrock()\n\nconf = LevenbergMarquardt_Conf()\nθ_init = zeros(parameter_size(nls))\nresult = solve(nls, θ_init, conf)","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"We can check that we find the same solution:","category":"page"},{"location":"unconstrained_nls/","page":"Unconstrained nonlinear least squares","title":"Unconstrained nonlinear least squares","text":"θ_solution = solution(result)","category":"page"}]
}
